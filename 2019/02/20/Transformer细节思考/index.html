<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="记录生活">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Transformer细节思考 |
    
    大嘴怪的小世界</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-Transformer细节思考" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Transformer细节思考
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/02/20/Transformer%E7%BB%86%E8%8A%82%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-02-20T15:04:53.000Z" itemprop="datePublished">2019-02-20</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>今天研究一下Transformer的一些细节，总结一下。</p>
<a id="more"></a>
<blockquote>
<p>参考：</p>
<p><a href="https://state-of-art.top/2019/01/17/Transformer%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/" target="_blank" rel="noopener">Transformer原理和实现-从入门到精通</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&amp;mid=2247484632&amp;idx=2&amp;sn=9170e3f036098b5d428123abc1ac1520&amp;source=41#wechat_redirect" target="_blank" rel="noopener">绝对干货！NLP预训练模型：从transformer到albert</a></p>
</blockquote>
<h1 id="Transformer图解"><a href="#Transformer图解" class="headerlink" title="Transformer图解"></a>Transformer图解</h1><p>Transformer使用self-attention和position-encoding替代原始的RNN。</p>
<p><img src="https://uploader.shimo.im/f/WVDQjP11Yteuyi8D.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>每一层encoder</p>
<p><img src="https://uploader.shimo.im/f/bpxADrZe0G5t4yKl.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>每一层decoder</p>
<p><img src="https://uploader.shimo.im/f/TCRzJC0pMGDm5MJz.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h1 id="Transformer具体结构"><a href="#Transformer具体结构" class="headerlink" title="Transformer具体结构"></a>Transformer具体结构</h1><p><img src="https://uploader.shimo.im/f/uXqNpDFaou7fzJlo.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id="加入Tensor"><a href="#加入Tensor" class="headerlink" title="加入Tensor"></a>加入Tensor</h2><p>输入的句子是一个词(ID)的序列，我们首先通过Embedding把它变成一个连续稠密的向量，如下图所示。</p>
<p><img src="https://uploader.shimo.im/f/7cQDKKuf7RJsUD3D.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>Embedding之后的序列会输入Encoder，首先经过Self-Attention层然后再经过全连接层，如下图所示。</p>
<p><img src="https://uploader.shimo.im/f/QCmk9C9Ee0OH3T6l.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>我们在计算𝑧𝑖时需要依赖所有时刻的输入𝑥1,…,𝑥𝑛，不过我们可以用矩阵运算一下子把所有的𝑧𝑖计算出来。而全连接网络的计算则完全是独立的，计算i时刻的输出只需要输入𝑧𝑖就足够了，因此很容易并行计算。下图更加明确的表达了这一点（注意全连接层每一个时刻的参数共享）。</p>
<p><img src="https://uploader.shimo.im/f/JA9x4GiSygcDqMiU.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h2><p>对于输入的每一个向量(第一层是词的Embedding，其它层是前一层的输出)，我们首先需要生成3个新的向量Q、K和V，分别代表查询(Query)向量、Key向量和Value向量。Q表示为了编码当前词，需要去注意(attend to)其它(其实也包括它自己)的词，我们需要有一个查询向量。而Key向量可以认为是这个词的关键的用于被检索的信息，而Value向量是真正的内容。</p>
<p>对于普通的Attention机制，其计算过程如下：</p>
<p><img src="https://uploader.shimo.im/f/EVMl6DTRHZFNfBj1.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>每个向量的Key和Value向量都是它本身，而Q是当前隐状态ℎ𝑡，计算energy的时候我们计算Q(ℎ𝑡)和Key(ℎ¯𝑗)。然后用softmax变成概率，最后把所有的ℎ¯𝑗加权平均得到context向量。</p>
<p>而Transformer使用的self-attention的计算，以t1时刻为例，如下图：</p>
<p><img src="https://uploader.shimo.im/f/OWcXBG6iT4eJlB1M.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>Self-Attention里的Query不是隐状态，并且来自当前输入向量本身，因此叫作Self-Attention。另外Key和Value都不是输入向量，而是输入向量做了一下线性变换。当然理论上这个线性变换矩阵可以是Identity矩阵，也就是使得Key=Value=输入向量。因此可以认为普通的Attention是这里的特例。这样做的好处是模型可以根据数据从输入向量中提取最适合作为Key(可以看成一种索引)和Value的部分。类似的，Query也是对输入向量做一下线性变换，它让系统可以根据任务学习出最适合的Query，从而可以注意到(attend to)特定的内容。</p>
<p>具体的计算过程：比如图中的输入是两个词”thinking”和”machines”，我们对它们进行Embedding(这是第一层，如果是后面的层，直接输入就是向量了)，得到向量𝑥1,𝑥2。接着我们用3个矩阵分别对它们进行变换，得到向量𝑞1,𝑘1,𝑣1和𝑞2,𝑘2,𝑣2。比如𝑞1=𝑥1𝑊𝑄。图中𝑥1的shape是1x4，𝑊𝑄是4x3，得到的𝑞1是1x3。其它的计算也是类似的，为了能够使得Key和Query可以内积，我们要求𝑊𝐾和𝑊𝑄的shape是一样的，但是并不要求𝑊𝑉和它们一定一样(虽然实际论文实现是一样的)。</p>
<p>每个时刻t都计算出𝑄𝑡,𝐾𝑡,𝑉𝑡之后，我们就可以来计算Self-Attention了。以第一个时刻为例，我们首先计算𝑞1和𝑘1,𝑘2的内积，得到score。接下来使用softmax把得分变成概率，注意这里把得分除以8, 即sqrt(𝑑𝑘)之后再计算的softmax，根据论文的说法，这样计算梯度时会更加稳定(stable)。接下来用softmax得到的概率对所有时刻的V求加权平均，这样就可以认为得到的向量根据Self-Attention的概率综合考虑了所有时刻的输入信息</p>
<h3 id="Self-Attention的矩阵运算"><a href="#Self-Attention的矩阵运算" class="headerlink" title="Self-Attention的矩阵运算"></a>Self-Attention的矩阵运算</h3><p>第一步还是计算Q、K和V，不过不是计算某个时刻的𝑞𝑡,𝑘𝑡,𝑣𝑡了，而是一次计算所有时刻的Q、K和V。计算过程如下图所示。这里的输入是一个矩阵，矩阵的第i行表示第i个时刻的输入𝑥𝑖。</p>
<p><img src="https://uploader.shimo.im/f/wAyzetkWzdIE6WcA.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>接下来就是计算Q和K得到score，然后除以sqrt(dk)，然后再softmax，最后加权平均得到输出。全过程如下图所示。</p>
<p><img src="https://uploader.shimo.im/f/7jg3ECgtzDcFQee7.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h3 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head-Attention"></a>Multi-Head-Attention</h3><p><img src="https://uploader.shimo.im/f/Gvl4v25HaKoSjmaW.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>对于输入矩阵(time_step, num_input)，每一组Q、K和V都可以得到一个输出矩阵Z(time_step, num_features):</p>
<p><img src="https://uploader.shimo.im/f/K4i3L8oDT17I4zq1.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>但是后面的全连接网络需要的输入是一个矩阵而不是多个矩阵，因此我们可以把多个head输出的Z按照第二个维度拼接起来，但是这样的特征有一些多，因此Transformer又用了一个线性变换(矩阵𝑊𝑂)对它进行了压缩:</p>
<p><img src="https://uploader.shimo.im/f/SxjNbR105DKJ0XLE.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>整体过程：</p>
<p><img src="https://uploader.shimo.im/f/5ybvl5baeI1eC0L5.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>可以Q、K、V在维度上比词嵌入向量更低。他们的维度是64，而词嵌入和编码器的输入/输出向量的维度是512. 但实际上不强求维度更小，这只是一种基于架构上的选择，它可以使多头注意力（multiheaded attention）的大部分计算保持不变。</p>
<h3 id="使用self-attention的好处"><a href="#使用self-attention的好处" class="headerlink" title="使用self-attention的好处"></a>使用self-attention的好处</h3><p>比如我们要翻译如下句子”The animal didn’t cross the street because it was too tired”(这个动物无法穿越马路，因为它太累了)。这里的it到底指代什么呢，是animal还是street？要知道具体的指代，我们需要在理解it的时候同时关注所有的单词，重点是animal、street和tired，然后根据知识(常识)我们知道只有animal才能tired，而street是不能tired的。Self-Attention用Encoder在编码一个词的时候会考虑句子中所有其它的词，从而确定怎么编码当前词。如果把tired换成narrow，那么it就指代的是street了。</p>
<p>而LSTM(即使是双向的)是无法实现上面的逻辑的。为什么呢？比如前向的LSTM，我们在编码it的时候根本没有看到后面是tired还是narrow，所有它无法把it编码成哪个词。而后向的LSTM呢？当然它看到了tired，但是到it的时候它还没有看到animal和street这两个单词，当然就更无法编码it的内容了。</p>
<p>当然多层的LSTM理论上是可以编码这个语义的，它需要下层的LSTM同时编码了animal和street以及tired三个词的语义，然后由更高层的LSTM来把it编码成animal的语义。但是这样模型更加复杂。</p>
<p>但如果使用multo-head的attention，在编码it的时候有一个Attention Head(后面会讲到)注意到了Animal，因此编码后的it有Animal的语义。</p>
<h2 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h2><p>位置编码有很多方法，其中需要考虑的一个重要因素就是需要它编码的是相对位置的关系。比如两个句子：”北京到上海的机票”和”你好，我们要一张北京到上海的机票”。显然加入位置编码之后，两个北京的向量是不同的了，两个上海的向量也是不同的了，但是我们期望Query(北京1)Key(上海1)却是等于Query(北京2)Key(上海2)的。具体的编码算法我们在代码部分再介绍。位置编码加入后的模型如下图所示：</p>
<p><img src="https://uploader.shimo.im/f/SRIZ4VF3sKXfDYIP.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><p>几乎所有的归一化方法都能起到平滑损失平面的作用，LN也一样。前面我们介绍过Batch Normalization，这个技巧能够让模型收敛的更快。但是Batch Normalization有一个问题——它需要一个minibatch的数据，而且这个minibatch不能太小(比如1)。另外一个问题就是它不能用于RNN，因为同样一个节点在不同时刻的分布是明显不同的。</p>
<p>假设我们的输入是一个minibatch的数据，我们再假设每一个数据都是一个向量，则输入是一个矩阵，每一行是一个训练数据，每一列都是一个特征。BatchNorm是对每个特征进行Normalization，而LayerNorm是对每个样本的不同特征进行Normalization，因此LayerNorm的输入可以是一行(一个样本)。</p>
<p>如下图所示，输入是(3,6)的矩阵，minibatch的大小是3，每个样本有6个特征。BatchNorm会对6个特征维度分别计算出6个均值和方差，然后用这两个均值和方差来分别对6个特征进行Normalization。而LayerNorm是分别对3个样本的6个特征求均值和方差，因此可以得到3个均值和方差，然后用这3个均值和方差对3个样本来做Normalization。</p>
<p><img src="https://uploader.shimo.im/f/TOvA2LPKMM1fykBk.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>BatchNorm看起来比较直观，我们在数据预处理也经常会把输入Normalize成均值为0，方差为1的数据，只不过它引入了可以学习的参数使得模型可以更加需要重新缓慢(不能剧烈)的调整均值和方差。而LayerNorm似乎有效奇怪，比如第一个特征是年龄，第二个特征是身高，把一个人的这两个特征求均值和方差似乎没有什么意义。论文里有一些讨论，都比较抽象。当然把身高和年龄平均并没有什么意义，但是对于其它层的特征，我们通过平均”期望”它们的取值范围大体一致，也可能使得神经网络调整参数更加容易，如果这两个特征实在有很大的差异，模型也可以学习出合适的参数让它来把取值范围缩放到更合适的区间。</p>
<h3 id="LN原理详解"><a href="#LN原理详解" class="headerlink" title="LN原理详解"></a>LN原理详解</h3><p>在Transformer中，LN被一笔带过，但却是不可或缺的一部分。每个子层的输出值为$\text { Layer } N o r m(x+\text { Sublayer }(x))$，这在网络结构图上非常明显（Norm即LN）。基本上所有的规范化技术，都可以概括为如下的公式：</p>
<ul>
<li>调整前：$h_{i}=f\left(a_{i}\right)$</li>
<li>调整后：$h_{i}^{\prime}=f\left(\frac{g_{i}}{\sigma_{i}}\left(a_{i}-u_{i}\right)+b_{i}\right)$</li>
</ul>
<p>对于隐层中某个节点的输出为对激活值 a_i 进行非线性变换 f() 后的h_i ，先使用均值$u$和方差$\sigma_{i}$对 $a_i$ 进行分布调整。如果将其理解成正态分布，就是把“高瘦”和“矮胖”的都调整回正常体型（深粉色），把偏离x=0的拉回中间来（淡紫色）。</p>
<p><img src="https://uploader.shimo.im/f/KOXOhpHIVBFM7fWl.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>这样做的第一个好处（平移）是，可以让激活值落入f()的梯度敏感区间（红色虚线的中间段）。梯度更新幅度变大，模型训练加快。第二个好处是，可以将每一次迭代的数据调整为相同分布（相当于“白化”），消除极端值，提升训练稳定性。</p>
<p>然而，在梯度敏感区内，隐层的输出接近于“线性”，模型表达能力会大幅度下降。引入 gain 因子g_i和 bias 因子b_i，为规范化后的分布再加入一点“个性”。需要注意的是， g_i和 b_i作为模型参数训练得到，$u_i$和$\sigma_{i}$在限定的数据范围内统计得到。BN 和 LN 的差别就在这里，前者在某一个 Batch 内统计某特定神经元节点的输出分布（跨样本），后者在某一次迭代更新中统计同一层内的所有神经元节点的输出分布（同一样本下）。</p>
<p>那么，为什么要舍弃 BN 改用 LN 呢？朴素版的 BN 是为 CNN 任务提出的，需要较大的 BatchSize 来保证统计量的可靠性，并在训练阶段记录全局的$u$和$\sigma$供预测任务使用。对于天然变长的 RNN 任务，需要对每个神经元进行在每个时序的状态进行统计。这不仅把原本非常简单的 BN 流程变复杂，更导致偏长的序列位置统计量不足。相比之下，LN 的使用限制就小很多，不需要在预测中使用训练阶段的统计量，即使 BatchSize = 1 也毫无影响。</p>
<p>个人理解，对于 CNN 图像类任务，每个卷积核可以看做特定的特征抽取器，对其输出做统计是有理可循的；对于 RNN 序列类任务，统计特定时序每个隐层的输出，毫无道理可言——序列中的绝对位置并没有什么显著的相关性。相反，同一样本同一时序同一层内，不同神经元节点处理的是相同的输入，在它们的输出间做统计合理得多。</p>
<p>从上面的分析可以看出，Normalization 通常被放在非线性化函数之前。以 GRU 为例，来看看 LN 是怎么设置的：</p>
<ul>
<li>$\left(\begin{array}{l}<br>\mathbf{z}_{t} \\<br>\mathbf{r}_{t}<br>\end{array}\right)=\mathbf{W}_{h} \mathbf{h}_{t-1}+\mathbf{W}_{x} \mathbf{x}_{t}$</li>
<li>$\hat{\mathbf{h}}_{t}=\tanh \left(\mathbf{W}_{\mathbf{x}_{t}}+\sigma\left(\mathbf{r}_{t}\right) \odot\left(\mathbf{U} \mathbf{h}_{t-1}\right) \mathbf{h}\right.$</li>
<li>$\mathbf{h}_{t}=\left(1-\sigma\left(\mathbf{z}_{t}\right)\right) \mathbf{h}_{t-1}+\sigma\left(\mathbf{z}_{t}\right) \hat{\mathbf{h}}_{\mathbf{t}}$</li>
</ul>
<p>可以看到，总体的原则是在“非线性之前单独处理各个矩阵”。对于 Transformer，主要的非线性部分在 FFN（ReLU） 和 Self-Attention（Softmax） 的内部，已经没有了显式的循环，但这些逐个叠加的同构子层像极了 GRU 和 LSTM 等 RNN 单元。信息的流动由沿着时序变成了穿过子层，把 LN 设置在每个子层的输出位置，意义上已经不再是“落入sigmoid 的梯度敏感空间来加速训练”了，个人认为更重要的是前文提到的“白化”—— 让每个词的向量化数值更加均衡，以消除极端情况对模型的影响，获得更稳定的深层网络结构 —— 就像这些词从 Embdding 层出来时候那样，彼此只有信息的不同，没有能量的多少。在和之前的 TWWT 实验一样的配置中，删除了全部的 LN 层后模型不再收敛。LN 正如 LSTM 中的tanh，它为模型提供非线性以增强表达能力，同时将输出限制在一定范围内。 因此，对于 Transformer 来说，LN 的效果已经不是“有多好“的范畴了，而是“不能没有”。</p>
<h3 id="MLP中的LN"><a href="#MLP中的LN" class="headerlink" title="MLP中的LN"></a>MLP中的LN</h3><p>设H是一层中隐层节点的数量，l是MLP的层数，我们可以计算LN的归一化统计量$u$和$\sigma$：</p>
<ul>
<li>$\mu^{l}=\frac{1}{H} \sum_{i=1}^{H} a_{i}^{l}$</li>
<li>$\sigma^{l}=\sqrt{\frac{1}{H} \sum_{i=1}^{H}\left(a_{i}^{l}-\mu^{l}\right)^{2}}$</li>
</ul>
<p>注意上面统计量的计算是和样本数量没有关系的，它的数量只取决于隐层节点的数量，所以只要隐层节点的数量足够多，我们就能保证LN的归一化统计量足够具有代表性。通过$u^l$和$\sigma^l$可以得到归一化后的值$\hat{\mathbf{a}}^{l}=\frac{\mathbf{a}^{l}-\mu^{l}}{\sqrt{\left(\sigma^{l}\right)^{2}+\epsilon}}$（其中$\epsilon$是一个很小的小数，防止除0）。</p>
<p>在LN中我们也需要一组参数来保证归一化操作不会破坏之前的信息，在LN中这组参数叫做增益（gain）g和偏置（bias) b（等同于BN中的$\gamma$和）$\beta$。假设激活函数为f，最终LN的输出为：$\mathbf{h}^{l}=f\left(\mathbf{g}^{l} \odot \hat{\mathbf{a}}^{l}+\mathbf{b}^{l}\right)$。合并公式并忽略参数l可以得到：$\mathbf{h}=f\left(\frac{\mathbf{g}}{\sqrt{\sigma^{2}+\epsilon}} \odot(\mathbf{a}-\mu)+\mathbf{b}\right)$</p>
<h3 id="RNN中的LN"><a href="#RNN中的LN" class="headerlink" title="RNN中的LN"></a>RNN中的LN</h3><p>在RNN中，我们可以非常简单的在每个时间片中使用LN，而且在任何时间片我们都能保证归一化统计量统计的是H个节点的信息。对于RNN时刻 t 时的节点，其输入是 t-1 时刻的隐层状态 h^{t-1}和 t 时刻的输入数据x_t，可以表示为：$\mathbf{a}^{t}=W_{h h} h^{t-1}+W_{x h} \mathbf{x}^{t}$。</p>
<p>接着我们便可以在$\mathbf{a}^{t}$上采取归一化过程：</p>
<ul>
<li>$\mu^{t}=\frac{1}{H} \sum_{i=1}^{H} a_{i}^{t}$</li>
<li>$\sigma^{t}=\sqrt{\frac{1}{H} \sum_{i=1}^{H}\left(a_{i}^{t}-\mu^{t}\right)^{2}}$</li>
<li>$\mathbf{h}^{t}=f\left(\frac{\mathbf{g}}{\sqrt{\left(\sigma^{t}\right)^{2}+\epsilon}} \odot\left(\mathbf{a}^{t}-\mu^{t}\right)+\mathbf{b}\right)$</li>
</ul>
<h4 id="LSTM中的LN"><a href="#LSTM中的LN" class="headerlink" title="LSTM中的LN"></a>LSTM中的LN</h4><p>LSTM的计算公式为：</p>
<ul>
<li>$\left(\begin{array}{c}<br>\mathbf{f}_{t} \\<br>\mathbf{i}_{t} \\<br>\mathbf{o}_{t} \\<br>\mathbf{g}_{t}<br>\end{array}\right)=\mathbf{W}_{h} \mathbf{h}_{t-1}+\mathbf{W}_{x} \mathbf{x}_{t}+b$</li>
<li>$\mathbf{c}_{t}=\sigma\left(\mathbf{f}_{t}\right) \odot \mathbf{c}_{t-1}+\sigma\left(\mathbf{i}_{t}\right) \odot \tanh \left(\mathbf{g}_{t}\right)$</li>
<li>$\mathbf{h}_{t}=\sigma\left(\mathbf{o}_{t}\right) \odot \tanh \left(\mathbf{c}_{t}\right)$</li>
</ul>
<p>使用了LN后的计算公式为：</p>
<ul>
<li>$\left(\begin{array}{c}<br>\mathbf{f}_{t} \\<br>\mathbf{i}_{t} \\<br>\mathbf{o}_{t} \\<br>g_{t}<br>\end{array}\right)=\quad L N\left(\mathbf{W}_{h} \mathbf{h}_{t-1} ; \boldsymbol{\alpha}_{1}, \boldsymbol{\beta}_{1}\right)+L N\left(\mathbf{W}_{x} \mathbf{x}_{t} ; \boldsymbol{\alpha}_{2}, \boldsymbol{\beta}_{2}\right)+b$</li>
<li>$\mathbf{c}_{t}=\sigma\left(\mathbf{f}_{t}\right) \odot \mathbf{c}_{t-1}+\sigma\left(\mathbf{i}_{t}\right) \odot \tanh \left(\mathbf{g}_{t}\right)$</li>
<li>$\mathbf{h}_{t}=\sigma\left(\mathbf{o}_{t}\right) \odot \tanh \left(L N\left(\mathbf{c}_{t} ; \boldsymbol{\alpha}_{3}, \boldsymbol{\beta}_{3}\right)\right)$</li>
</ul>
<h3 id="对照实验"><a href="#对照实验" class="headerlink" title="对照实验"></a>对照实验</h3><p>这里我们设置了一组对照试验来对比普通网络，BN以及LN在MLP和RNN上的表现。</p>
<h4 id="MLP上的归一化"><a href="#MLP上的归一化" class="headerlink" title="MLP上的归一化"></a>MLP上的归一化</h4><p>这里使用的是MNIST数据集，但是归一化操作只添加到了后面的MLP部分。Keras官方源码中没有LN的实现，我们可以通过<code>pip install keras-layer-normalization</code>进行安装，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from keras_layer_normalization import LayerNormalization</span><br><span class="line"># 构建LN CNN网络</span><br><span class="line">model_ln &#x3D; Sequential()</span><br><span class="line">model_ln.add(Conv2D(input_shape &#x3D; (28,28,1), filters&#x3D;6, kernel_size&#x3D;(5,5), padding&#x3D;&#39;valid&#39;, activation&#x3D;&#39;tanh&#39;))</span><br><span class="line">model_ln.add(MaxPool2D(pool_size&#x3D;(2,2), strides&#x3D;2))</span><br><span class="line">model_ln.add(Conv2D(input_shape&#x3D;(14,14,6), filters&#x3D;16, kernel_size&#x3D;(5,5), padding&#x3D;&#39;valid&#39;, activation&#x3D;&#39;tanh&#39;))</span><br><span class="line">model_ln.add(MaxPool2D(pool_size&#x3D;(2,2), strides&#x3D;2))</span><br><span class="line">model_ln.add(Flatten())</span><br><span class="line">model_ln.add(Dense(120, activation&#x3D;&#39;tanh&#39;))</span><br><span class="line">model_ln.add(LayerNormalization()) # 添加LN运算</span><br><span class="line">model_ln.add(Dense(84, activation&#x3D;&#39;tanh&#39;))</span><br><span class="line">model_ln.add(LayerNormalization())</span><br><span class="line">model_ln.add(Dense(10, activation&#x3D;&#39;softmax&#39;))</span><br></pre></td></tr></table></figure>
<p>另外两个对照试验也使用了这个网络结构，不同点在于归一化部分。图3左侧是batchsize=128时得到的收敛曲线，从中我们可以看出BN和LN均能取得加速收敛的效果，且BN的效果要优于LN。图3右侧是batchsize=8是得到的收敛曲线，这时BN反而会减慢收敛速度，验证了我们上面的结论，对比之下LN要轻微的优于无归一化的网络，说明了LN在小尺度批量上的有效性：<br><img src="https://uploader.shimo.im/f/8jLUlejv9kLBLD4n.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"><img src="https://uploader.shimo.im/f/hpHSt6yZW9dhXRKY.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h4 id="LSTM上的归一化"><a href="#LSTM上的归一化" class="headerlink" title="LSTM上的归一化"></a>LSTM上的归一化</h4><p>另外一组对照实验是基于imdb的二分类任务，使用了glove作为词嵌入。这里设置了无LN的LSTM和带LN的LSTM的作为对照试验，网络结构如下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lstm_ln import LSTM_LN</span><br><span class="line">model_ln &#x3D; Sequential()</span><br><span class="line">model_ln.add(Embedding(max_features,100))</span><br><span class="line">model_ln.add(LSTM_LN(128))</span><br><span class="line">model_ln.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line">model_ln.summary()</span><br></pre></td></tr></table></figure>
<p>LN对于RNN系列动态网络的收敛加速上的效果是略有帮助的。LN的有点主要体现在两个方面：</p>
<ul>
<li>LN得到的模型更稳定；</li>
<li>LN有正则化的作用，得到的模型更不容易过拟合。</li>
</ul>
<h2 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h2><p>每个Self-Attention层都会加一个残差连接，然后是一个LayerNorm层，如下图所示：</p>
<p><img src="https://uploader.shimo.im/f/9JnJi8vn7Izidhmp.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>下图展示了更多细节：输入𝑥1、𝑥2经self-attention层之后变成𝑧1、𝑧2，然后和残差连接的输入𝑥1、𝑥2加起来，然后经过LayerNorm层输出给全连接层。全连接层也是有一个残差连接和一个LayerNorm层，最后再输出给上一层：</p>
<p><img src="https://uploader.shimo.im/f/smiABSb61r8rvfqg.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>这样做的好处不言而喻，避免了梯度消失（求导时多了一个常数项）。</p>
<h2 id="Decoder层"><a href="#Decoder层" class="headerlink" title="Decoder层"></a>Decoder层</h2><p>Decoder和Encoder是类似的，如下图所示，区别在于它多了一个Encoder-Decoder Attention层，这个层的输入除了来自Self-Attention之外还有Encoder最后一层的所有时刻的输出。Encoder-Decoder Attention层的Query来自下一层，而Key和Value则来自Encoder的输出。</p>
<p><img src="https://uploader.shimo.im/f/IuBCl1ZxZG9BKh5z.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>在这个框架下，解码器实际上可看成一个神经网络语言模型，预测的时候，target中的每一个单词是逐个生成的，当前词的生成依赖两方面：一是Encoder的输出，二是target的前面的单词。例如，在生成第一个单词是，不仅依赖于Encoder的输出，还依赖于起始标志[CLS]；生成第二个单词是，不仅依赖Encoder的输出，还依赖起始标志和第一个单词…依此类推。这其实是说，在翻译当前词的时候，是看不到后面的要翻译的词。由上可以看出，这里的mask是动态的。</p>
<h1 id="Transformer细节讨论"><a href="#Transformer细节讨论" class="headerlink" title="Transformer细节讨论"></a>Transformer细节讨论</h1><h2 id="Scaled-Dot-product-Attention"><a href="#Scaled-Dot-product-Attention" class="headerlink" title="Scaled Dot-product Attention"></a>Scaled Dot-product Attention</h2><p><img src="https://uploader.shimo.im/f/wUrUGWRx6fOH6zaP.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>首先， Q 与 K 进行了一个点积操作，这个其实就是我在Attention讲到的 score 操作。然后，有一个 Scale 操作，其实就是为了防止结果过大，除以一个尺度标度 sqrt(dk)（注：主要因为dk比较大时，点乘注意力的表现变差，认为是由于点乘后的值过大，导致softmax函数趋近于边缘，梯度较小）， 其中dk是Q中一个向量的维度。再然后，经过一个Mask操作； Mask操作是将需要隐藏的数据设置为负无穷，这样经过后面的 Softmax 后就接近于 0，这样这些数据就不会对后续结果产生影响了。最后经过一个 Softmax 层， 然后计算 Attention Value。其公式：$\text {Attention}(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V$</p>
<p>这里解释一下 Scaled Dot-product Attention 在本文中的应用，也是称为 Self-Attention 的原因所在，这里的Q，K， V 都是一样的，意思就是说，这里是句子对句子自己进行Attention 来查找句子中词之间的关系，这是一件很厉害的事情，回想LSTM是怎么做的，再比较 Self-Attention， 直观的感觉，Self-Attention更能把握住词与词的语义特征，而LSTM对长依赖的句子，往往毫无办法，表征极差。</p>
<p>常用的attention主要有“Add-相加”和“Mul-相乘”两种：</p>
<ul>
<li>$\operatorname{score}\left(h_{j}, s_{i}\right)=<v, \tanh \left(W_{1} h_{j}+W_{2} s_{i}\right)>[A d d]$</li>
<li>$\operatorname{score}\left(h_{j}, s_{i}\right)=\left\langle W_{1} h_{j}, W_{2} s_{i}&gt;\quad[M u l]\right.$</li>
</ul>
<p>矩阵加法的计算更简单，但是外面套着tanh和 v，相当于一个完整的隐层。在整体计算复杂度上两者接近，但考虑到矩阵乘法已经有了非常成熟的加速算法，Transformer采用了Mul形式。</p>
<p>在模型效果上，《Massive Exploration of Neural Machine Translation Architectures》对不同Attention-Dimension (d_k) 下的Add和Mul进行了对比，如下图：</p>
<p><img src="https://uploader.shimo.im/f/I3AO3zusDdNUXzMC.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>可以看到，在$d_k$较小的时候，Add和Mul相差不大；随着$d_k$增大，Add明显超越了Mul。Transformer 设置 d_k=64虽然不在表格的范围内，但是可以推测Add仍略优于Mul。作者认为，$d_k$的增大将点积结果推向了softmax函数的梯度平缓区，影响了训练的稳定性。原话是这么说的：</p>
<blockquote>
<p>We suspect that for large values of dk, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients.</p>
</blockquote>
<p>因此，Transformer 为“dot-product attention”加了一个前缀“scaled”，即引入一个温度因子（temperature）$\sqrt{d_{k}}$，中文全称“缩放的点积注意力网络”：$\text {Attention}(Q, K, V)=\operatorname{softmax}\left(Q K^{T} / \sqrt{d_{k}}\right) V$</p>
<p>等等，Add也离不开softmax，怎么没有这个问题呢？首先，左侧v的导数就是 tanh的输出，后者本身就是 [-1,1]之间的，一定不会超限。然后，右侧 W_1的导数就是隐层h_j ，必然是sigmoid或者其他激活函数的输出，值也不会太大。</p>
<p>回到Mul。左侧W_1的导数来自于$h_{j}\left(W_{2} s_{i}\right)$。如果s_i分布在(0,1)，那么$W_{2} s_{i}$就会扩展到(0, d_k) ，即点积可能会造成一个非常大的梯度值。</p>
<h2 id="MultiHeadAttention"><a href="#MultiHeadAttention" class="headerlink" title="MultiHeadAttention"></a>MultiHeadAttention</h2><p>Transformer 中使用 Multi-head Attention要注意以下几点：</p>
<p>首先， 在Encoder与Decoder中的黑色框中，采用的都是是 Self-Attention ，Q，K，V 同源。</p>
<p>其次，需要注意的是只有在Decoder中的Muti-head中才有 Mask 操作，而在Encoder中却没有，这是因为我们在预测第t个词时，需要将 t 时刻及以后的词遮住，只对前面的词进行 self-attention。</p>
<p>最后， 在黄色框中， 采用的是传统的Attention思路，Q 来自Decoder层， 而 K， V来自Encoder的输出 。</p>
<h2 id="最后的Linear与Softmax"><a href="#最后的Linear与Softmax" class="headerlink" title="最后的Linear与Softmax"></a>最后的Linear与Softmax</h2><p>一般都会在最后一层加一个前馈神经网络来增加泛化能力，最后用一个 softmax 来进行预测。</p>
<p>线性层的参数个数为d_model vocab_size， 一般来说，vocab_size会比较大，拿20000为例，那么只这层的参数就有51220000个，约为10的8次方，非常惊人。而在词向量那一层，同样也是这个数值，所以，一种比较好的做法是将这两个全连接层的参数共享，会节省不少内存，而且效果也不会差。</p>
<p>注意：在Encoder的输入embedding、Decoder的输入embedding后，增加了1个scale因子，而生成下一词汇的linear transformation前却未添加scale因子。</p>
<h2 id="Position-Embedding"><a href="#Position-Embedding" class="headerlink" title="Position Embedding"></a>Position Embedding</h2><p>在下图中，每一行对应一个词向量的位置编码，所以第一行对应着输入序列的第一个词。每行包含512个值，每个值介于1和-1之间。我们已经对它们进行了颜色编码，所以图案是可见的。20字(行)的位置编码实例，词嵌入大小为512(列)。你可以看到它从中间分裂成两半。这是因为左半部分的值由一个函数(使用正弦)生成，而右半部分由另一个函数(使用余弦)生成。然后将它们拼在一起而得到每一个位置编码向量。这种编码的优点是能够扩展到未知的序列长度(例如，当我们训练出的模型需要翻译远比训练集里的句子更长的句子时)。</p>
<ul>
<li>$P E_{(p o s, 2 i)}=\sin \left(p o s / 10000^{2 i / d_{\text {mod }}}\right)$</li>
<li>$P E_{(p o s, 2 i+1)}=\cos \left(p o s / 10000^{2 i / d_{\text {model }}}\right)$</li>
</ul>
<p><img src="https://uploader.shimo.im/f/Su3SrWtdY1L1R7zr.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>首先，可以证明出每个位置都能获得唯一的编码。其次，i决定了频率的大小，不同的i可以看成是不同的频率空间中的编码，是相互正交的，通过改变i的值，就能得到多维度的编码，类似于词向量的维度。这里2i&lt;=512（$d_{model}$）, 一共512维。想象一下，当2i大于$d_{model}$时会出现什么情况，这时sin函数的周期会变得非常大，函数值会非常接近于0，这显然不是我们希望看到的，因为这样和词向量就不在一个量级了，位置编码的作用被削弱了。另外，值得注意的是，位置编码是不参与训练的，而词向量是参与训练的。作者通过实验发现，位置编码参与训练与否对最终的结果并无影响。</p>
<p>其次，之所以对奇偶位置分别编码，论文中是这样解释的：</p>
<blockquote>
<p>We chose this function because we hypothesized it would allow the model to easily learn to attend by relative positions, since for any fixed offset k, PEpos+k can be represented as a linear function of PEpos.</p>
</blockquote>
<p>相隔 k 个词的两个位置 pos 和 pos+k 的位置编码是由 k 的位置编码定义的一个线性变换，推导公式如下：</p>
<ul>
<li>$P E(p o s+k, 2 i)=P E(p o s, 2 i) P E(k, 2 i+1)+P E(p o s, 2 i+1) P E(k, 2 i)$</li>
<li>$P E(p o s+k, 2 i+1)=P E(p o s, 2 i+1) P E(k, 2 i+1)-P E(p o s, 2 i) P E(k, 2 i)$</li>
</ul>
<p>或者下面的推导更清晰一些：</p>
<ul>
<li>$\begin{aligned}<br>P E_{(p o s+k, 2 i)} &amp;=\sin \left((p o s+k) / 10000^{2 i / d_{\text {model}}}\right) \\<br>&amp;=\sin \left(p o s / 10000^{2 i / d_{\text {model}}}\right) \cos \left(k / 10000^{2 i / d_{\text {model}}}\right)+\cos \left(p o s / 10000^{2 i / d_{\text {model}}}\right) \sin \left(k / 10000^{2 i / d_{\text {model}}}\right) \\<br>&amp;=\cos \left(k / 10000^{2 i / d_{\text {model}}}\right) P E_{(p o s, 2 i)}+\sin \left(k / 10000^{2 i / d_{\text {model}}}\right) P E_{(p o s, 2 i+1)}<br>\end{aligned}$</li>
<li>$\begin{aligned}<br>P E_{(p o s+k, 2 i+1)} &amp;=\cos \left((p o s+k) / 10000^{2 i / d_{\text {model}}}\right) \\<br>&amp;=\cos \left(\text {pos} / 10000^{2 i / d_{\text {model}}}\right) \cos \left(k / 10000^{2 i / d_{\text {model}}}\right)-\sin \left(p o s / 10000^{2 i / d_{\text {model}}}\right) \sin \left(k / 10000^{2 i / d_{\text {model}}}\right) \\<br>&amp;=\cos \left(k / 10000^{2 i / d_{\text {model}}}\right) P E_{(p o s, 2 i+1)}-\sin \left(k / 10000^{2 i / d_{\text {model}}}\right) P E_{(\text {pos}, 2 i)}<br>\end{aligned}$</li>
</ul>
<h2 id="前馈网络"><a href="#前馈网络" class="headerlink" title="前馈网络"></a>前馈网络</h2><p>每个encoderLayer中，多头attention后会接一个前馈网络。这个前馈网络其实是两个全连接层，进行了如下操作：$FFN(x)=max(0,xW1+b1)W2+b2$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.w_1 &#x3D; nn.Linear(d_model, d_ff)</span><br><span class="line"># self.w_1 &#x3D; nn.Conv1d(in_features&#x3D;d_model, out_features&#x3D;d_ff, kenerl_size&#x3D;1)</span><br><span class="line">self.w_2 &#x3D; nn.Linear(d_ff, d_model)</span><br><span class="line"># self.w_2 &#x3D; nn.Conv1d(in_features&#x3D;d_ff, out_features&#x3D;d_model, kenerl_size&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>这两层的作用等价于两个 kenerl_size=1的一维卷积操作。<br>FFN 相当于将每个位置的Attention结果映射到一个更大维度的特征空间，然后使用ReLU引入非线性进行筛选，最后恢复回原始维度。需要说明的是，在抛弃了 LSTM 结构后，FFN 中的 ReLU成为了一个主要的能提供非线性变换的单元。</p>
<h2 id="Weight-Tying"><a href="#Weight-Tying" class="headerlink" title="Weight Tying"></a>Weight Tying</h2><p>论文的3.4小节Embeddings and Softmax，有这样一句话：</p>
<blockquote>
<p>In our model, we share the same weight matrix between the two embedding layers and the pre-softmax linear transformation, similar to [29].</p>
</blockquote>
<p>《Using the Output Embedding to Improve Language Models》这篇文章主要介绍的是RNNLM中的Weight Tying技术，不仅能压缩LM的大小，还能显著改善PPL表现。作者为了证明算法的普适性，在NMT任务上也进行了扩展实验。在seq2seq模型中，decoder可以近似地看作RNNLM，它必不可少地有一个embedding矩阵$U \in R^{C \times H}$和一个pre-softmax矩阵$V \in R^{C \times H}$，来完成词表大小C到隐层大小H的尺度转换：$h_{i n}=U^{T} C, \ldots, h_{p r e_{-} s o f t m a x}=V h_{o u t}$</p>
<p>。Weight Tying在操作上非常简单，即令U=V 。在OPEN-NMT的Pytorch实现版本中，仅仅一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if model_opt.share_decoder_embeddings:</span><br><span class="line">    generator[0].weight &#x3D; decoder.embeddings.word_lut.weight</span><br></pre></td></tr></table></figure>
<p>Transformer在英法和英德上，混用了源语言和目标语言的词表，因此使用了升级版的TWWT（Three way weight tying），把encoder的embedding层权重，也加入共享：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if model_opt.share_embeddings:</span><br><span class="line">    tgt_emb.word_lut.weight &#x3D; src_emb.word_lut.weight</span><br></pre></td></tr></table></figure>
<p>虽然weight共享了，但是embedding和pre-softmax仍然是两个不同的层，因为bias是彼此独立的。<br>在我个人的理解中，one-hot向量和对U的操作是“指定抽取”，即取出某个单词的向量行；pre-softmax对U的操作是“逐个点积”，对隐层的输出，依次计算其和每个单词向量行的变换结果。虽然具体的操作不同，但在本质上，U和V都是对任一的单词进行向量化表示（H列），然后按词表序stack起来（C行）。因此，两个权重矩阵在语义上是相通的。</p>
<p>也是由于上面两种操作方式的不同，U在反向传播中不如V训练得充分。将两者绑定在一起，缓和了这一问题，可以训练得到质量更高的新矩阵。另外，由于词表大小C通常比模型隐层大小H高出一个数量级，Weight Tying 可以显著减小模型的参数量。这个数据在论文中是28%~51%，我使用Transformer-base在非共享词表的英中方向上进行测试，模型参数量从 131,636,930 减小到 102,177,474，足足的22%。模型更小，收敛更快更容易。</p>
<p>下图是知乎上网友用Transformer-base模型跑的实验结果，绿色是Weight Tying版本，蓝色是基础版本。X轴为step，Y轴为Appromix BLEU。可以看到，两者的收敛速度接近，曲线平稳后绿色明显优于蓝色，峰值相差0.17。</p>
<p><img src="https://uploader.shimo.im/f/wi59MAoPcUomITKw.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id="Label-Smoothing"><a href="#Label-Smoothing" class="headerlink" title="Label Smoothing"></a>Label Smoothing</h2><p>Label Smoothing是一种正则化技术，核心功能就是防止过拟合，它的全称是 Label Smoothing Regularization（LSR），是 2015 年的经典论文《Rethinking the Inception Architecture for Computer Vision》的一个副产品。作者认为 LSR 可以避免模型 too confident。关于这一点论文里没有详细的解释，不过对于 NMT 任务来说，鼓励模型产生多样化的译文确实会帮助提升 BLEU 值，毕竟标准译文并不是唯一的。</p>
<p>最著名的正则化技术，dropout，通过随机抹掉一些节点来削弱彼此之间的依赖，通常设置在网络内部隐层。作为 dropout 的配合策略，LSR 考虑的是 softmax 层。</p>
<p>假设目标类别为y，任意类别为，ground-truth 分布为q(k)，模型预测分布为p(k)。显然，当k=y时，q(k)=1。当k!=y时，q(k)=0。LSR 为了让模型的输出不要过于贴合单点分布，选择在 gound-truth 中加入噪声。即削弱y的概率，并整体叠加一个独立于训练样例的均匀分布u(k)：$q^{\prime}(k)=(1-\epsilon) q(k)+\epsilon u(k)=(1-\epsilon) q(k)+\epsilon / K$。其中K是 softmax 的类别数。拆开来写可以看得清楚一点：</p>
<ul>
<li>$q^{\prime}(k)=1-\epsilon+\epsilon / K, \quad k=y$</li>
<li>$q^{\prime}(k)=\epsilon / K, \quad k \neq y$</li>
</ul>
<p>所有类别的概率和仍然是归一的。说白了就是把最高点砍掉一点，多出来的概率平均分给所有人。调整之后，交叉熵（损失函数）也随之变化：$H\left(q^{\prime}, p\right)=(1-\epsilon) H(q, p)+\epsilon H(u \cdot p)$。对于两个完全一致的分布，其交叉熵为0。LSR 可以看作是在优化目标中加入了正则项 H(u, p)，在模型输出偏离均匀分布时施以惩罚。</p>
<h2 id="Warmup-amp-Noam学习率更新"><a href="#Warmup-amp-Noam学习率更新" class="headerlink" title="Warmup &amp; Noam学习率更新"></a>Warmup &amp; Noam学习率更新</h2><h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>论文提出了一个全新的学习率更新公式：$\text {lrate}=d_{\text {model}}^{-0.5} \cdot \min \left(\text {step_num}^{-0.5}, \text {step_num} \cdot \text {warmup_steps}^{-1.5}\right)$</p>
<p>如果把min去掉的话，就变成一个以warmup_steps为分界点的分段函数。在该点之后，$\text { lrate }=d_{\text {model }}^{-0.5} \cdot \text { step_num }^{-0.5}$，是 decay 的部分。常用方法有指数衰减（exponential）、分段常数衰减（piecewise-constant）、反时限衰减（inverse-time）等等。Transformer 采用了负幂的形式，衰减速度先快后慢。</p>
<p>在该点之前，$\text { lrate }=d_{\text {model}}^{-0.5} \cdot \text { step_num } \cdot \text { warmup_steps}^{-1.5}$，是 warmup 的部分。Transformer 采用了线性函数的形式，warmup_steps 越大，斜率越小。</p>
<p><img src="https://uploader.shimo.im/f/bxxdHqj3LdOeu2mt.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>画在图上明显很多。Transformer 的学习率更新公式叫作“noam”，它将 warmup 和 decay 两个部分组合在一起，总体趋势是先增加后减小。</p>
<p>warmup为什么有效? 可参考<a href="https://www.zhihu.com/question/338066667" target="_blank" rel="noopener">https://www.zhihu.com/question/338066667</a>、<a href="https://zhuanlan.zhihu.com/p/45410279" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45410279</a>。</p>
<h3 id="weight-decay"><a href="#weight-decay" class="headerlink" title="weight-decay"></a>weight-decay</h3><h4 id="指数衰减"><a href="#指数衰减" class="headerlink" title="指数衰减"></a>指数衰减</h4><p>指数衰减学习率是先使用较大的学习率来快速得到一个较优的解，然后随着迭代的继续,逐步减小学习率，使得模型在训练后期更加稳定。Transfomer使用的是指数衰减。指数衰减学习率的公式：$\text { decayed_learning_rate = learning_rate\cdotdecay_rate }^{(\text {global_step} / \text {decay_steps})}$</p>
<p>global_step是计数器,从0计数到训练的迭代次数，learning_rate是初始化的学习率，decayed_learning_rate是随着 global_step递增而衰减。显然，当global_step为初值0时， 有下面等式：$\text { decayed_learning_rate = learning_rate }$。</p>
<p>decay_steps用来控制衰减速度，如果decay_steps大一些, global_step/decay_steps就会增长缓慢一些。从而指数衰减学习率decayed_learning_rate就会衰减得慢一否则学习率很快就会衰减为趋近于0。</p>
<p>具体代码可参考：<a href="https://zhuanlan.zhihu.com/p/29421235" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29421235</a></p>
<h4 id="分段常数衰减"><a href="#分段常数衰减" class="headerlink" title="分段常数衰减"></a>分段常数衰减</h4><pre><code>参考：[https://www.jianshu.com/p/125fe2ab085b](https://www.jianshu.com/p/125fe2ab085b)
</code></pre><h4 id="自然指数衰减"><a href="#自然指数衰减" class="headerlink" title="自然指数衰减"></a>自然指数衰减</h4><p>它与指数衰减方式相似，不同的在于它的衰减底数是e，故而其收敛的速度更快，一般用于相对比较容易训练的网络，便于较快的收敛，其更新规则如下：$\text { decayed_learning_rate = learning_rate } * e^{\frac{-d e c a y_{r a t e}}{g l b b a_{s t e p}}}$</p>
<p>下图为为分段常数衰减、指数衰减、自然指数衰减三种方式的对比图，红色的即为分段常数衰减图，阶梯型曲线。蓝色线为指数衰减图，绿色即为自然指数衰减图，很明可以看到自然指数衰减方式下的学习率衰减程度要大于一般指数衰减方式，有助于更快的收敛。</p>
<p><img src="https://uploader.shimo.im/f/Pw9NQo5Yu503saf7.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h4 id="多项式衰减"><a href="#多项式衰减" class="headerlink" title="多项式衰减"></a>多项式衰减</h4><p>应用多项式衰减的方式进行更新学习率，这里会给定初始学习率和最低学习率取值，然后将会按照给定的衰减方式将学习率从初始值衰减到最低值,其更新规则如下式所示：</p>
<ul>
<li>$\text { global_step }=\min (\text {global_step, decay_steps})$</li>
<li>$\begin{array}{c}<br>\text { decayed_learning_rate }=(\text {learning_rate}-\text {end_learning_rate}) *\left(1-\frac{\text {global_step}}{\text {decay_steps}}\right)^{\text {powe}} \\<br>+\text {end_learning_rate}<br>\end{array}$</li>
</ul>
<p>需要注意的是，有两个机制，降到最低学习率后，到训练结束可以一直使用最低学习率进行更新，另一个是再次将学习率调高，使用 decay_steps 的倍数，取第一个大于 global_steps 的结果，它是用来防止神经网络在训练的后期由于学习率过小而导致的网络一直在某个局部最小值附近震荡，这样可以通过在后期增大学习率跳出局部极小值。</p>
<p>如下图所示，红色线代表学习率降低至最低后，一直保持学习率不变进行更新，绿色线代表学习率衰减到最低后，又会再次循环往复的升高降低。</p>
<p><img src="https://uploader.shimo.im/f/TWHJqCaUQytQ7SLS.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h4 id="余弦衰减"><a href="#余弦衰减" class="headerlink" title="余弦衰减"></a>余弦衰减</h4><p>余弦衰减就是采用余弦的相关方式进行学习率的衰减，衰减图和余弦函数相似。其更新机制如下式所示：</p>
<ul>
<li>$\text { global_step }=\min (\text {global_step, decay_steps})$</li>
<li>$\text {cosine_decay}=0.5 <em>\left(1+\cos \left(\pi </em> \frac{\text {global_step}}{\text {decay_steps}}\right)\right)$</li>
<li>$\text { decayed }=(1-\alpha) * \text { cosine_decay }+\alpha$</li>
<li>$\text { decayed_learning_rate = learning_rate * decayed }$</li>
</ul>
<p>如下图所示，红色即为标准的余弦衰减曲线，学习率从初始值下降到最低学习率后保持不变。蓝色的线是线性余弦衰减方式曲线，它是学习率从初始学习率以线性的方式下降到最低学习率值。绿色噪声线性余弦衰减方式：</p>
<p><img src="https://uploader.shimo.im/f/B2zQIXMV8trD31KQ.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id="Masking"><a href="#Masking" class="headerlink" title="Masking"></a>Masking</h2><h3 id="pad-mask"><a href="#pad-mask" class="headerlink" title="pad mask"></a>pad mask</h3><p>通常也是编码端的mask</p>
<p><img src="https://uploader.shimo.im/f/n9R8KVx3vwWbU3Wu.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h3 id="sequence-mask"><a href="#sequence-mask" class="headerlink" title="sequence mask"></a>sequence mask</h3><p><img src="https://uploader.shimo.im/f/UcgsvQ46WN33NjqJ.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h3 id="解码端的mask要同时考虑pad-mask和sequece-mask"><a href="#解码端的mask要同时考虑pad-mask和sequece-mask" class="headerlink" title="解码端的mask要同时考虑pad mask和sequece mask"></a>解码端的mask要同时考虑pad mask和sequece mask</h3><p><img src="https://uploader.shimo.im/f/D2Nwlz6tyDopu7un.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="Word-Piece"><a href="#Word-Piece" class="headerlink" title="Word Piece"></a>Word Piece</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>现在基本性能好一些的NLP模型，例如OpenAI GPT，google的BERT，在数据预处理的时候都会有WordPiece的过程。WordPiece字面理解是把word拆成piece一片一片，其实就是这个意思。</p>
<p>WordPiece的一种主要的实现方式叫做BPE（Byte-Pair Encoding）双字节编码。</p>
<p>BPE的过程可以理解为把一个单词再拆分，使得我们的此表会变得精简，并且寓意更加清晰。</p>
<p>比如”loved”,”loving”,”loves”这三个单词。其实本身的语义都是“爱”的意思，但是如果我们以单词为单位，那它们就算不一样的词，在英语中不同后缀的词非常的多，就会使得词表变的很大，训练速度变慢，训练的效果也不是太好。</p>
<p>BPE算法通过训练，能够把上面的3个单词拆分成”lov”,”ed”,”ing”,”es”几部分，这样可以把词的本身的意思和时态分开，有效的减少了词表的数量。</p>
<h3 id="BPE算法"><a href="#BPE算法" class="headerlink" title="BPE算法"></a>BPE算法</h3><blockquote>
<p>参考：<a href="https://plmsmile.github.io/2017/10/19/subword-units/" target="_blank" rel="noopener">https://plmsmile.github.io/2017/10/19/subword-units/</a></p>
</blockquote>
<p>BPE的大概训练过程：首先将词分成一个一个的字符，然后在词的范围内统计字符对出现的次数，每次将次数最多的字符对保存起来，直到循环次数结束。</p>
<p>我们模拟一下BPE算法。</p>
<ul>
<li>我们原始词表如下：{‘l o w e r ‘: 2, ‘n e w e s t ‘: 6, ‘w i d e s t ‘: 3, ‘l o w ‘: 5}</li>
<li>其中的key是词表的单词拆分层字母，再加代表结尾，value代表词出现的频率。</li>
<li>下面我们每一步在整张词表中找出频率最高相邻序列，并把它合并，依次循环。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原始词表 &#123;&#39;l o w e r &lt;&#x2F;w&gt;&#39;: 2, &#39;n e w e s t &lt;&#x2F;w&gt;&#39;: 6, &#39;w i d e s t &lt;&#x2F;w&gt;&#39;: 3, &#39;l o w &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;s&#39;, &#39;t&#39;) 9</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;n e w e st &lt;&#x2F;w&gt;&#39;: 6, &#39;l o w e r &lt;&#x2F;w&gt;&#39;: 2, &#39;w i d e st &lt;&#x2F;w&gt;&#39;: 3, &#39;l o w &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;e&#39;, &#39;st&#39;) 9</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;l o w e r &lt;&#x2F;w&gt;&#39;: 2, &#39;l o w &lt;&#x2F;w&gt;&#39;: 5, &#39;w i d est &lt;&#x2F;w&gt;&#39;: 3, &#39;n e w est &lt;&#x2F;w&gt;&#39;: 6&#125;</span><br><span class="line">出现最频繁的序列 (&#39;est&#39;, &#39;&lt;&#x2F;w&gt;&#39;) 9</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;l o w e r &lt;&#x2F;w&gt;&#39;: 2, &#39;n e w est&lt;&#x2F;w&gt;&#39;: 6, &#39;l o w &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;l&#39;, &#39;o&#39;) 7</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;lo w e r &lt;&#x2F;w&gt;&#39;: 2, &#39;n e w est&lt;&#x2F;w&gt;&#39;: 6, &#39;lo w &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;lo&#39;, &#39;w&#39;) 7</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2, &#39;n e w est&lt;&#x2F;w&gt;&#39;: 6, &#39;low &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;n&#39;, &#39;e&#39;) 6</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2, &#39;ne w est&lt;&#x2F;w&gt;&#39;: 6, &#39;low &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;w&#39;, &#39;est&lt;&#x2F;w&gt;&#39;) 6</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2, &#39;ne west&lt;&#x2F;w&gt;&#39;: 6, &#39;low &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;ne&#39;, &#39;west&lt;&#x2F;w&gt;&#39;) 6</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2, &#39;newest&lt;&#x2F;w&gt;&#39;: 6, &#39;low &lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;low&#39;, &#39;&lt;&#x2F;w&gt;&#39;) 5</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w i d est&lt;&#x2F;w&gt;&#39;: 3, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2, &#39;newest&lt;&#x2F;w&gt;&#39;: 6, &#39;low&lt;&#x2F;w&gt;&#39;: 5&#125;</span><br><span class="line">出现最频繁的序列 (&#39;i&#39;, &#39;d&#39;) 3</span><br><span class="line">合并最频繁的序列后的词表 &#123;&#39;w id est&lt;&#x2F;w&gt;&#39;: 3, &#39;newest&lt;&#x2F;w&gt;&#39;: 6, &#39;low&lt;&#x2F;w&gt;&#39;: 5, &#39;low e r &lt;&#x2F;w&gt;&#39;: 2&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们通过BPE得到了更加合适的词表了，这个词表可能会出现一些不是单词的组合，但是这个本身是有意义的一种形式，加速NLP的学习，提升不同词之间的语义的区分度。</p>
<h3 id="join-BPE"><a href="#join-BPE" class="headerlink" title="join BPE"></a>join BPE</h3><p>为目标语言和原语言一起使用BPE，即联合两种语言的词典去做BPE。提高了源语言和目标语言的分割一致性。训练中一般concat两种语言。</p>
<p>机器翻译时，编码与解码共享wordpiece model，可以处理翻译时目标语言和当前语言直接拷贝的词情况。</p>
<h2 id="阻止训练发散的方法"><a href="#阻止训练发散的方法" class="headerlink" title="阻止训练发散的方法"></a>阻止训练发散的方法</h2><p>降低学习速率、增加warmup_steps以及引入梯度截断。</p>
<h2 id="Dropout使用"><a href="#Dropout使用" class="headerlink" title="Dropout使用"></a>Dropout使用</h2><p>dropout设置在word embedding与position embedding相加之后，以及add+layernorm之前。</p>
<h2 id="Checkpoint-average"><a href="#Checkpoint-average" class="headerlink" title="Checkpoint average"></a>Checkpoint average</h2><p>指将训练一段时间的存储的checkpoint（文中选择为5个或20个），将这些checkpoint的所有模型的参数求平均。</p>
<h2 id="Xavier-初始化"><a href="#Xavier-初始化" class="headerlink" title="Xavier 初始化"></a>Xavier 初始化</h2><p>在官方 tensor2tensor 代码中，可以看到关于 weight 参数初始化的时候，采用了一种叫作xavier_uniform 的方法。也可以简称为 Xavier（读作 [ˈzeɪvjər]） 或者 Glorot，来自于作者 Xavier Glorot 在 2010 年和 Bengio 大神一起发表的《Understanding the difficulty of training deep feedforward neural networks》。</p>
<p>Xavier 是一种均匀初始化。其基线是朴素版本，即对于包含 n_i 个输入单元的网络层 layer_i ，其 weight 的初始值均匀采样自$\left[-1 / \sqrt{\left.\left.\left(n_{i}\right), 1 / \sqrt{(} n_{i}\right)\right]}\right.$。作者发现，在深层神经网络中，朴素版本的均匀初始化和激活函数（sigmoid 与 tanh）配合得不好。具体说来，就是不仅收敛得慢，训练平稳后的模型效果还差。如果使用预训练的模型来初始化网络，则能够明显改善训练过程。因此，作者认为，更换初始化方式是可取的。</p>
<p><img src="https://uploader.shimo.im/f/jhBiphXgghzG5p9R.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>首先来看看 sigmoid。它的线性区在 0.5 附近，偏向 1 或 0 表示则表示饱和。在理想情况下，激活值应当落在表达能力最强的非线性区间，远离线性区与饱和区。然而，在实际训练中，输出层 layer-4 在很长一段时间内都接近下饱和（黑）；其他层由上往下离线性区越来越近（蓝绿红）。虽然从 epoch-100 开始慢慢正常了，但这显然拖慢了收敛过程。</p>
<p><img src="https://uploader.shimo.im/f/kv4jPjIkXP58VeD1.png!thumbnail?fileGuid=vTCtKG6hgHqVrCJD" alt="图片"></p>
<p>然后是正负对称的 tanh。随着训练进行，自下而上（红绿蓝黑青），各层慢慢地都落入了饱和区。明明验证集的效果还达不到预期，模型却“训不动”了。</p>
<p>那么，我们需要什么样的激活值分布呢？一个标准的第 i 层可以分为线性$s^{i}=z^{i} W^{i}+b^{i}$和非线性$z^{i+1}=f\left(s^{i}\right)$两部分。在深层网络中，激活值的方差会自下而上逐层累积， 链式推导可得：$\operatorname{Var}\left[z^{i}\right]=\operatorname{Var}[x] \prod_{j=0}^{i-1} n_{j} \operatorname{Var}\left[W^{j}\right]$</p>
<p>对于反向传播，假定输出落在激活函数的线性区，即$f^{\prime}\left(s_{k}^{i}\right) \approx 1$。同样应用链式法则，各参数的梯度为（d 为总层数）：</p>
<ul>
<li>$\operatorname{Var}\left[\frac{\partial \text { cost }}{s^{i}}\right]=\operatorname{Var}\left[\frac{\partial \text { cost }}{s^{d}}\right] \prod_{j=i}^{d} n_{j+1} \operatorname{Var}\left[W^{j}\right]$</li>
<li>$\operatorname{Var}\left[\frac{\partial \operatorname{cost}}{w^{i}}\right]=\operatorname{Var}\left[\frac{\partial \operatorname{cost}}{s^{i}}\right] \operatorname{Var}\left[z^{i}\right]$</li>
</ul>
<p>现在要回到正题上了。一个稳定的深层网络，要求$\operatorname{Var}\left[z^{i}\right]$和$\operatorname{Var}\left[\partial \operatorname{cost} / s^{i}\right]$在各层保持一致，这样可以让激活值（forward）始终远离饱和区，并且梯度（backward）不会消失或爆炸。根据上面的公式，可以得到约束目标：$\forall i, n_{i} \operatorname{Var}\left[W^{i}\right]=1=n^{i+1} \operatorname{Var}\left[W^{i}\right]$</p>
<p>于方差是和输入单元的个数有关的，所以正向和反向分别使用了$n_i$和$n_{i+1}$。这两个等式显然不能同时成立，只好折中一下，让$\operatorname{Var}\left[W^{i}\right]=2 /\left(n_{i}+n_{i+1}\right)$。补充一条基础知识，对于均匀分布U[a,b] ，其方差为$(b-a)^{2} / 12$。现在开始解方程，让 a=b 并且$(b-a)^{2} / 12=2 /\left(n_{i}+n_{i+1}\right)$，得到 Xavier 均匀分布的最终形式：$U\left[-\sqrt{\frac{6}{n_{i}+n_{i+1}}}, \quad \sqrt{\frac{6}{n_{i}+n_{i+1}}}\right]$</p>
<h2 id="Transformer有哪些缺点"><a href="#Transformer有哪些缺点" class="headerlink" title="Transformer有哪些缺点"></a>Transformer有哪些缺点</h2><ul>
<li>评价不同模型需要考虑的是：<ul>
<li>句法特征提取能力</li>
<li>语义特征提取能力：Transformer &gt;&gt; 原生CNN == 原生RNN</li>
<li>长距离特征捕获能力：Transformer &gt; 原生RNN &gt;&gt; 原生CNN</li>
<li>任务综合特征抽取能力：Transformer最强</li>
<li>并行计算能力及运行效率：Transformer = 原生CNN &gt;&gt; 原生RNN</li>
</ul>
</li>
<li>超长文本：Transformer-XL</li>
<li>计算简化：ALBert</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="majsunflower.cn/2019/02/20/Transformer%E7%BB%86%E8%8A%82%E6%80%9D%E8%80%83/" data-id="ckj75g8q9000ebcwv3suwa8ko"
         class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transformer/" rel="tag">Transformer</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/03/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E3%80%8ALattice-CNNs-for-Matching-Based-Chinese-Question-Answering%E3%80%8B/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            论文阅读：《Lattice CNNs for Matching Based Chinese Question Answering》
          
        </div>
      </a>
    
    
      <a href="/2019/02/07/%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">用GitHub+Hexo搭建个人网站</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'a0115c330d8e2a88dc59',
      clientSecret: '2e456ec13123a898d7b34ad8e117f543a6f379ea',
      repo: 'majing2019.github.io',
      owner: 'majing2019',
      admin: ['majing2019'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 大嘴怪的小世界</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/shark.svg" alt="大嘴怪的小世界"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>




<script src="/js/ocean.js"></script>


</body>
</html>