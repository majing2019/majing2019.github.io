<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="记录生活">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    PLY教程及例子 |
    
    大嘴怪的小世界</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-PLY教程及例子" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      PLY教程及例子
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/03/PLY%E6%95%99%E7%A8%8B%E5%8F%8A%E4%BE%8B%E5%AD%90/" class="article-date">
  <time datetime="2020-03-03T12:10:49.000Z" itemprop="datePublished">2020-03-03</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>最近需要重改语音助手中的计算器模块，打算用yacc&amp;lex实现，在这里记录一下学习和使用过程。</p>
<a id="more"></a>
<blockquote>
<p>参考：<br><a href="https://github.com/PChou/python-lex-yacc" target="_blank" rel="noopener">https://github.com/PChou/python-lex-yacc</a></p>
</blockquote>
<h1 id="PLY教程"><a href="#PLY教程" class="headerlink" title="PLY教程"></a>PLY教程</h1><h2 id="PLY简介"><a href="#PLY简介" class="headerlink" title="PLY简介"></a>PLY简介</h2><p>PLY 是纯粹由 Python 实现的 Lex 和 yacc（流行的编译器构建工具）。PLY 的设计目标是尽可能的沿袭传统 lex 和 yacc 工具的工作方式，包括支持 LALR(1)分析法、提供丰富的输入验证、错误报告和诊断。因此，如果你曾经在其他编程语言下使用过 yacc，你应该能够很容易的迁移到 PLY 上。</p>
<p>PLY 包含两个独立的模块：lex.py 和 yacc.py，都定义在 ply 包下。lex.py 模块用来将输入字符通过一系列的正则表达式分解成标记序列，yacc.py 通过一些上下文无关的文法来识别编程语言语法。yacc.py 使用 LR 解析法，并使用 LALR(1)算法（默认）或者 SLR 算法生成分析表。</p>
<p>这两个工具是为了一起工作的。lex.py 通过向外部提供token()方法作为接口，方法每次会从输入中返回下一个有效的标记。yacc.py 将会不断的调用这个方法来获取标记并匹配语法规则。yacc.py 的功能通常是生成抽象语法树(AST)，不过，这完全取决于用户，如果需要，yacc.py 可以直接用来完成简单的翻译。</p>
<p>就像相应的 unix 工具，yacc.py 提供了大多数你期望的特性，其中包括：丰富的错误检查、语法验证、支持空产生式、错误的标记、通过优先级规则解决二义性。事实上，传统 yacc 能够做到的 PLY 都应该支持。</p>
<p>yacc.py 与 Unix 下的 yacc 的主要不同之处在于，yacc.py 没有包含一个独立的代码生成器，而是在 PLY 中依赖反射来构建词法分析器和语法解析器。不像传统的 lex/yacc 工具需要一个独立的输入文件，并将之转化成一个源文件，Python 程序必须是一个可直接可用的程序，这意味着不能有额外的源文件和特殊的创建步骤（像是那种执行 yacc 命令来生成 Python 代码）。又由于生成分析表开销较大，PLY 会缓存生成的分析表，并将它们保存在独立的文件中，除非源文件有变化，会重新生成分析表，否则将从缓存中直接读取。</p>
<h2 id="LEX简介"><a href="#LEX简介" class="headerlink" title="LEX简介"></a>LEX简介</h2><p>lex.py是用来将输入字符串标记化。例如，假设你正在设计一个编程语言，用户的输入字符串如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 3 + 42 * (s - t)</span><br></pre></td></tr></table></figure>
<p>标记器将字符串分割成独立的标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;x&#39;,&#39;&#x3D;&#39;, &#39;3&#39;, &#39;+&#39;, &#39;42&#39;, &#39;*&#39;, &#39;(&#39;, &#39;s&#39;, &#39;-&#39;, &#39;t&#39;, &#39;)&#39;</span><br></pre></td></tr></table></figure><br>标记通常用一组名字来命名和表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;ID&#39;,&#39;EQUALS&#39;,&#39;NUMBER&#39;,&#39;PLUS&#39;,&#39;NUMBER&#39;,&#39;TIMES&#39;,&#39;LPAREN&#39;,&#39;ID&#39;,&#39;MINUS&#39;,&#39;ID&#39;,&#39;RPAREN&#39;</span><br></pre></td></tr></table></figure><br>将标记名和标记值本身组合起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#39;ID&#39;,&#39;x&#39;), (&#39;EQUALS&#39;,&#39;&#x3D;&#39;), (&#39;NUMBER&#39;,&#39;3&#39;),(&#39;PLUS&#39;,&#39;+&#39;), (&#39;NUMBER&#39;,&#39;42), (&#39;TIMES&#39;,&#39;*&#39;),(&#39;LPAREN&#39;,&#39;(&#39;), (&#39;ID&#39;,&#39;s&#39;),(&#39;MINUS&#39;,&#39;-&#39;),(&#39;ID&#39;,&#39;t&#39;), (&#39;RPAREN&#39;,&#39;)</span><br></pre></td></tr></table></figure></p>
<h3 id="LEX例子"><a href="#LEX例子" class="headerlink" title="LEX例子"></a>LEX例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import ply.lex as lex</span><br><span class="line"></span><br><span class="line"># List of token names.   This is always required</span><br><span class="line">tokens &#x3D; (</span><br><span class="line">   &#39;NUMBER&#39;,</span><br><span class="line">   &#39;PLUS&#39;,</span><br><span class="line">   &#39;MINUS&#39;,</span><br><span class="line">   &#39;TIMES&#39;,</span><br><span class="line">   &#39;DIVIDE&#39;,</span><br><span class="line">   &#39;LPAREN&#39;,</span><br><span class="line">   &#39;RPAREN&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Regular expression rules for simple tokens</span><br><span class="line">t_PLUS    &#x3D; r&#39;\+&#39;</span><br><span class="line">t_MINUS   &#x3D; r&#39;-&#39;</span><br><span class="line">t_TIMES   &#x3D; r&#39;\*&#39;</span><br><span class="line">t_DIVIDE  &#x3D; r&#39;&#x2F;&#39;</span><br><span class="line">t_LPAREN  &#x3D; r&#39;\(&#39;</span><br><span class="line">t_RPAREN  &#x3D; r&#39;\)&#39;</span><br><span class="line"></span><br><span class="line"># A regular expression rule with some action code</span><br><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;\d+&#39;</span><br><span class="line">    t.value &#x3D; int(t.value)    </span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line"># Define a rule so we can track line numbers</span><br><span class="line">def t_newline(t):</span><br><span class="line">    r&#39;\n+&#39;</span><br><span class="line">    t.lexer.lineno +&#x3D; len(t.value)</span><br><span class="line"></span><br><span class="line"># A string containing ignored characters (spaces and tabs)</span><br><span class="line">t_ignore  &#x3D; &#39; \t&#39;</span><br><span class="line"></span><br><span class="line"># Error handling rule</span><br><span class="line">def t_error(t):</span><br><span class="line">    print(&quot;Illegal character &#39;%s&#39;&quot; % t.value[0])</span><br><span class="line">    t.lexer.skip(1)</span><br><span class="line"></span><br><span class="line"># Build the lexer</span><br><span class="line">lexer &#x3D; lex.lex()</span><br></pre></td></tr></table></figure>
<p>为了使 lexer 工作，你需要给定一个输入，并传递给input()方法。然后，重复调用token()方法来获取标记序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Test it out</span><br><span class="line">data &#x3D; &#39;&#39;&#39;</span><br><span class="line">3 + 4 * 10</span><br><span class="line">  + -20 *2</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"># Give the lexer some input</span><br><span class="line">lexer.input(data)</span><br><span class="line"></span><br><span class="line"># Tokenize</span><br><span class="line">for tok in lexer:</span><br><span class="line">    if not tok: break      # No more input</span><br><span class="line">    print(tok.type, tok.value, tok.lineno, tok.lexpos)</span><br></pre></td></tr></table></figure><br>程序执行，将给出如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LexToken(NUMBER,3,2,1)</span><br><span class="line">LexToken(PLUS,&#39;+&#39;,2,3)</span><br><span class="line">LexToken(NUMBER,4,2,5)</span><br><span class="line">LexToken(TIMES,&#39;*&#39;,2,7)</span><br><span class="line">LexToken(NUMBER,10,2,10)</span><br><span class="line">LexToken(PLUS,&#39;+&#39;,3,14)</span><br><span class="line">LexToken(MINUS,&#39;-&#39;,3,16)</span><br><span class="line">LexToken(NUMBER,20,3,18)</span><br><span class="line">LexToken(TIMES,&#39;*&#39;,3,20)</span><br><span class="line">LexToken(NUMBER,2,3,21)</span><br></pre></td></tr></table></figure><br>tok.type和tok.value属性表示标记本身的类型和值。tok.line和tok.lexpos属性包含了标记的位置信息，tok.lexpos表示标记相对于输入串起始位置的偏移。</p>
<h3 id="标记列表"><a href="#标记列表" class="headerlink" title="标记列表"></a>标记列表</h3><p>词法分析器必须提供一个标记的列表，这个列表将所有可能的标记告诉分析器，用来执行各种验证，同时也提供给 yacc.py 作为终结符。在上面的例子中，标记列表是由tokens指定的。</p>
<h3 id="标记的规则"><a href="#标记的规则" class="headerlink" title="标记的规则"></a>标记的规则</h3><p>每种标记用一个正则表达式规则来表示，每个规则需要以”t_”开头声明，表示该声明是对标记的规则定义。对于简单的标记，可以定义成这样（在 Python 中使用 raw string 能比较方便的书写正则表达式）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_PLUS &#x3D; r&#39;\+&#39;</span><br></pre></td></tr></table></figure>
<p>这里，紧跟在 t_ 后面的单词，必须跟标记列表中的某个标记名称对应。如果需要执行动作的话，规则可以写成一个方法。例如，下面的规则匹配数字字串，并且将匹配的字符串转化成 Python 的整型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;\d+&#39;</span><br><span class="line">    t.value &#x3D; int(t.value)</span><br><span class="line">    return t</span><br></pre></td></tr></table></figure><br>如果使用方法的话，正则表达式写成方法的文档字符串。方法总是需要接受一个 LexToken 实例的参数，该实例有一个 t.type 的属性（字符串表示）来表示标记的类型名称，t.value 是标记值（匹配的实际的字符串），t.lineno 表示当前在源输入串中的作业行，t.lexpos 表示标记相对于输入串起始位置的偏移。默认情况下，t.type 是以t_开头的变量或方法的后面部分。方法可以在方法体里面修改这些属性。但是，如果这样做，应该返回结果 token，否则，标记将被丢弃。<br>在 lex 内部，lex.py 用re模块处理模式匹配，在构造最终的完整的正则式的时候，用户提供的规则按照下面的顺序加入：</p>
<ul>
<li>所有由方法定义的标记规则，按照他们的出现顺序依次加入</li>
<li>由字符串变量定义的标记规则按照其正则式长度倒序后，依次加入（长的先入）</li>
<li>顺序的约定对于精确匹配是必要的。比如，如果你想区分‘=’和‘==’，你需要确保‘==’优先检查。如果用字符串来定义这样的表达式的话，通过将较长的正则式先加入，可以帮助解决这个问题。用方法定义标记，可以显示地控制哪个规则优先检查。</li>
</ul>
<p>为了处理保留字，你应该写一个单一的规则来匹配这些标识，并在方法里面作特殊的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reserved &#x3D; &#123;</span><br><span class="line">   &#39;if&#39; : &#39;IF&#39;,</span><br><span class="line">   &#39;then&#39; : &#39;THEN&#39;,</span><br><span class="line">   &#39;else&#39; : &#39;ELSE&#39;,</span><br><span class="line">   &#39;while&#39; : &#39;WHILE&#39;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tokens &#x3D; [&#39;LPAREN&#39;,&#39;RPAREN&#39;,...,&#39;ID&#39;] + list(reserved.values())</span><br><span class="line"></span><br><span class="line">def t_ID(t):</span><br><span class="line">    r&#39;[a-zA-Z_][a-zA-Z_0-9]*&#39;</span><br><span class="line">    t.type &#x3D; reserved.get(t.value,&#39;ID&#39;)    # Check for reserved words</span><br></pre></td></tr></table></figure>
<pre><code>return t
</code></pre><p>这样做可以大大减少正则式的个数，并稍稍加快处理速度。注意：你应该避免为保留字编写单独的规则，例如，如果你像下面这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t_FOR   &#x3D; r&#39;for&#39;</span><br><span class="line">t_PRINT &#x3D; r&#39;print&#39;</span><br></pre></td></tr></table></figure><br>但是，这些规则照样也能够匹配以这些字符开头的单词，比如’forget’或者’printed’，这通常不是你想要的。</p>
<h3 id="标记的值"><a href="#标记的值" class="headerlink" title="标记的值"></a>标记的值</h3><p>标记被 lex 返回后，它们的值被保存在value属性中。正常情况下，value 是匹配的实际文本。事实上，value 可以被赋为任何 Python 支持的类型。例如，当扫描到标识符的时候，你可能不仅需要返回标识符的名字，还需要返回其在符号表中的位置，可以像下面这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def t_ID(t):</span><br><span class="line">    ...</span><br><span class="line">    # Look up symbol table information and return a tuple</span><br><span class="line">    t.value &#x3D; (t.value, symbol_lookup(t.value))</span><br><span class="line">    ...</span><br><span class="line">    return t</span><br></pre></td></tr></table></figure>
<p>需要注意的是，不推荐用其他属性来保存值，因为 yacc.py 模块只会暴露出标记的 value属 性，访问其他属性会变得不自然。如果想保存多种属性，可以将元组、字典、或者对象实例赋给 value。</p>
<h3 id="丢弃标记"><a href="#丢弃标记" class="headerlink" title="丢弃标记"></a>丢弃标记</h3><p>想丢弃像注释之类的标记，只要不返回 value 就行了，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def t_COMMENT(t):</span><br><span class="line">    r&#39;\#.*&#39;</span><br><span class="line">    pass</span><br><span class="line">    # No return value. Token discarded</span><br></pre></td></tr></table></figure>
<p>为标记声明添加”ignore_”前缀同样可以达到目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_ignore_COMMENT &#x3D; r&#39;\#.*&#39;</span><br></pre></td></tr></table></figure><br>如果有多种文本需要丢弃，建议使用方法来定义规则，因为方法能够提供更精确的匹配优先级控制（方法根据出现的顺序，而字符串的正则表达式依据正则表达式的长度）</p>
<h3 id="行号和位置信息"><a href="#行号和位置信息" class="headerlink" title="行号和位置信息"></a>行号和位置信息</h3><p>默认情况下，lex.py 对行号一无所知。因为 lex.py 根本不知道何为”行”的概念（换行符本身也作为文本的一部分）。不过，可以通过写一个特殊的规则来记录行号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Define a rule so we can track line numbers</span><br><span class="line">def t_newline(t):</span><br><span class="line">    r&#39;\n+&#39;</span><br><span class="line">    t.lexer.lineno +&#x3D; len(t.value)</span><br></pre></td></tr></table></figure>
<p>在这个规则中，当前 lexer 对象 t.lexer 的 lineno 属性被修改了，而且空行被简单的丢弃了，因为没有任何的返回。<br>lex.py 也不自动做列跟踪。但是，位置信息被记录在了每个标记对象的lexpos属性中，这样，就有可能来计算列信息了。例如：每当遇到新行的时候就重置列值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Compute column. input is the input text string token is a token instance</span><br><span class="line">def find_column(input,token):</span><br><span class="line">    last_cr &#x3D; input.rfind(&#39;\n&#39;,0,token.lexpos)</span><br><span class="line">    if last_cr &lt; 0:</span><br><span class="line">        last_cr &#x3D; 0</span><br><span class="line">    column &#x3D; (token.lexpos - last_cr) + 1</span><br><span class="line">    return column</span><br></pre></td></tr></table></figure>
<p>通常，计算列的信息是为了指示上下文的错误位置，所以只在必要时有用。</p>
<h3 id="忽略字符"><a href="#忽略字符" class="headerlink" title="忽略字符"></a>忽略字符</h3><p>t_ignore规则比较特殊，是lex.py所保留用来忽略字符的，通常用来跳过空白或者不需要的字符。虽然可以通过定义像t_newline()这样的规则来完成相同的事情，不过使用t_ignore能够提供较好的词法分析性能，因为相比普通的正则式，它被特殊化处理了。用PLY写一个简单计算器</p>
<h3 id="字面字符"><a href="#字面字符" class="headerlink" title="字面字符"></a>字面字符</h3><p>字面字符可以通过在词法模块中定义一个literals变量做到，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">literals &#x3D; [ &#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;&#x2F;&#39; ]</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">literals &#x3D; &quot;+-*&#x2F;&quot;</span><br></pre></td></tr></table></figure><br>字面字符是指单个字符，表示把字符本身作为标记，标记的type和value都是字符本身。不过，字面字符是在其他正则式之后被检查的，因此如果有规则是以这些字符开头的，那么这些规则的优先级较高。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>最后，在词法分析中遇到非法字符时，t_error()用来处理这类错误。这种情况下，t.value包含了余下还未被处理的输入字串，在之前的例子中，错误处理方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Error handling rule</span><br><span class="line">def t_error(t):</span><br><span class="line">    print &quot;Illegal character &#39;%s&#39;&quot; % t.value[0]</span><br><span class="line">    t.lexer.skip(1)</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们只是简单的输出不合法的字符，并且通过调用t.lexer.skip(1)跳过一个字符。</p>
<h3 id="构建和使用-lexer"><a href="#构建和使用-lexer" class="headerlink" title="构建和使用 lexer"></a>构建和使用 lexer</h3><p>函数lex.lex()使用 Python 的反射机制读取调用上下文中的正则表达式，来创建 lexer。lexer 一旦创建好，有两个方法可以用来控制 lexer 对象：</p>
<ul>
<li>lexer.input(data) 重置 lexer 和输入字串</li>
<li>lexer.token() 返回下一个 LexToken 类型的标记实例，如果进行到输入字串的尾部时将返回None</li>
</ul>
<p>推荐直接在 lex() 函数返回的 lexer 对象上调用上述接口，尽管也可以向下面这样用模块级别的 lex.input() 和 lex.token()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lex.lex()</span><br><span class="line">lex.input(sometext)</span><br><span class="line">while 1:</span><br><span class="line">    tok &#x3D; lex.token()</span><br><span class="line">    if not tok: break</span><br><span class="line">    print tok</span><br></pre></td></tr></table></figure>
<p>在这个例子中，lex.input() 和 lex.token() 是模块级别的方法，在 lex 模块中，input() 和 token() 方法绑定到最新创建的 lexer 对象的对应方法上。最好不要这样用，因为这种接口可能不知道在什么时候就失效（例如垃圾回收）。</p>
<h3 id="TOKEN-装饰器"><a href="#TOKEN-装饰器" class="headerlink" title="@TOKEN 装饰器"></a>@TOKEN 装饰器</h3><p>在一些应用中，你可能需要定义一系列辅助的记号来构建复杂的正则表达式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">digit            &#x3D; r&#39;([0-9])&#39;</span><br><span class="line">nondigit         &#x3D; r&#39;([_A-Za-z])&#39;</span><br><span class="line">identifier       &#x3D; r&#39;(&#39; + nondigit + r&#39;(&#39; + digit + r&#39;|&#39; + nondigit + r&#39;)*)&#39;        </span><br><span class="line"></span><br><span class="line">def t_ID(t):</span><br><span class="line">    # want docstring to be identifier above. ?????</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们希望 ID 的规则引用上面的已有的变量。然而，使用文档字符串无法做到，为了解决这个问题，你可以使用@TOKEN装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from ply.lex import TOKEN</span><br><span class="line"></span><br><span class="line">@TOKEN(identifier)</span><br><span class="line">def t_ID(t):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>装饰器可以将 identifier 关联到 t_ID() 的文档字符串上以使 lex.py 正常工作，一种等价的做法是直接给文档字符串赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def t_ID(t):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">t_ID.__doc__ &#x3D; identifier</span><br></pre></td></tr></table></figure></p>
<h3 id="优化模式"><a href="#优化模式" class="headerlink" title="优化模式"></a>优化模式</h3><p>为了提高性能，你可能希望使用 Python 的优化模式（比如，使用 -o 选项执行 Python）。然而，这样的话，Python 会忽略文档字串，这是 lex.py 的特殊问题，可以通过在创建 lexer 的时候使用 optimize 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lexer &#x3D; lex.lex(optimize&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>接着，用 Python 常规的模式运行，这样，lex.py 会在当前目录下创建一个 lextab.py 文件，这个文件会包含所有的正则表达式规则和词法分析阶段的分析表。然后，lextab.py 可以被导入用来构建 lexer。这种方法大大改善了词法分析程序的启动时间，而且可以在 Python 的优化模式下工作。<br>想要更改生成的文件名，使用如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lexer &#x3D; lex.lex(optimize&#x3D;1,lextab&#x3D;&quot;footab&quot;)</span><br></pre></td></tr></table></figure>
<p>在优化模式下执行，需要注意的是 lex 会被禁用大多数的错误检查。因此，建议只在确保万事俱备准备发布最终代码时使用。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>如果想要调试，可以使 lex() 运行在调试模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lexer &#x3D; lex.lex(debug&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>这将打出一些调试信息，包括添加的规则、最终的正则表达式和词法分析过程中得到的标记。除此之外，lex.py 有一个简单的主函数，不但支持对命令行参数输入的字串进行扫描，还支持命令行参数指定的文件名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;</span><br><span class="line">     lex.runmain()</span><br></pre></td></tr></table></figure></p>
<h3 id="其他方式定义词法规则"><a href="#其他方式定义词法规则" class="headerlink" title="其他方式定义词法规则"></a>其他方式定义词法规则</h3><p>上面的例子，词法分析器都是在单个的 Python 模块中指定的。如果你想将标记的规则放到不同的模块，使用 module 关键字参数。例如，你可能有一个专有的模块，包含了标记的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># module: tokrules.py</span><br><span class="line"># This module just contains the lexing rules</span><br><span class="line"></span><br><span class="line"># List of token names.   This is always required</span><br><span class="line">tokens &#x3D; (</span><br><span class="line">   &#39;NUMBER&#39;,</span><br><span class="line">   &#39;PLUS&#39;,</span><br><span class="line">   &#39;MINUS&#39;,</span><br><span class="line">   &#39;TIMES&#39;,</span><br><span class="line">   &#39;DIVIDE&#39;,</span><br><span class="line">   &#39;LPAREN&#39;,</span><br><span class="line">   &#39;RPAREN&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Regular expression rules for simple tokens</span><br><span class="line">t_PLUS    &#x3D; r&#39;\+&#39;</span><br><span class="line">t_MINUS   &#x3D; r&#39;-&#39;</span><br><span class="line">t_TIMES   &#x3D; r&#39;\*&#39;</span><br><span class="line">t_DIVIDE  &#x3D; r&#39;&#x2F;&#39;</span><br><span class="line">t_LPAREN  &#x3D; r&#39;\(&#39;</span><br><span class="line">t_RPAREN  &#x3D; r&#39;\)&#39;</span><br><span class="line"></span><br><span class="line"># A regular expression rule with some action code</span><br><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;\d+&#39;</span><br><span class="line">    t.value &#x3D; int(t.value)    </span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line"># Define a rule so we can track line numbers</span><br><span class="line">def t_newline(t):</span><br><span class="line">    r&#39;\n+&#39;</span><br><span class="line">    t.lexer.lineno +&#x3D; len(t.value)</span><br><span class="line"></span><br><span class="line"># A string containing ignored characters (spaces and tabs)</span><br><span class="line">t_ignore  &#x3D; &#39; \t&#39;</span><br><span class="line"></span><br><span class="line"># Error handling rule</span><br><span class="line">def t_error(t):</span><br><span class="line">    print &quot;Illegal character &#39;%s&#39;&quot; % t.value[0]</span><br></pre></td></tr></table></figure>
<pre><code>t.lexer.skip(1)
</code></pre><p>现在，如果你想要从不同的模块中构建分析器，应该这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tokrules</span><br><span class="line">import ply.lex as lex</span><br><span class="line"></span><br><span class="line">lexer &#x3D; lex.lex(module&#x3D;tokrules)</span><br><span class="line">lexer.input(&quot;3 + 4&quot;)</span><br><span class="line">for tok in lexer:</span><br><span class="line">    if not tok: break      # No more input</span><br><span class="line">    print(tok.type, tok.value, tok.lineno, tok.lexpos)</span><br></pre></td></tr></table></figure><br>module选项也可以指定类型的实例，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import ply.lex as lex</span><br><span class="line"></span><br><span class="line">class MyLexer:</span><br><span class="line">    # List of token names.   This is always required</span><br><span class="line">    tokens &#x3D; (</span><br><span class="line">       &#39;NUMBER&#39;,</span><br><span class="line">       &#39;PLUS&#39;,</span><br><span class="line">       &#39;MINUS&#39;,</span><br><span class="line">       &#39;TIMES&#39;,</span><br><span class="line">       &#39;DIVIDE&#39;,</span><br><span class="line">       &#39;LPAREN&#39;,</span><br><span class="line">       &#39;RPAREN&#39;,</span><br><span class="line">    )</span><br><span class="line">    # Regular expression rules for simple tokens</span><br><span class="line">    t_PLUS    &#x3D; r&#39;\+&#39;</span><br><span class="line">    t_MINUS   &#x3D; r&#39;-&#39;</span><br><span class="line">    t_TIMES   &#x3D; r&#39;\*&#39;</span><br><span class="line">    t_DIVIDE  &#x3D; r&#39;&#x2F;&#39;</span><br><span class="line">    t_LPAREN  &#x3D; r&#39;\(&#39;</span><br><span class="line">    t_RPAREN  &#x3D; r&#39;\)&#39;</span><br><span class="line">    # A regular expression rule with some action code</span><br><span class="line">    # Note addition of self parameter since we&#39;re in a class</span><br><span class="line">    def t_NUMBER(self,t):</span><br><span class="line">        r&#39;\d+&#39;</span><br><span class="line">        t.value &#x3D; int(t.value)    </span><br><span class="line">        return t</span><br><span class="line">    # Define a rule so we can track line numbers</span><br><span class="line">    def t_newline(self,t):</span><br><span class="line">        r&#39;\n+&#39;</span><br><span class="line">        t.lexer.lineno +&#x3D; len(t.value)</span><br><span class="line">    # A string containing ignored characters (spaces and tabs)</span><br><span class="line">    t_ignore  &#x3D; &#39; \t&#39;</span><br><span class="line">    # Error handling rule</span><br><span class="line">    def t_error(self,t):</span><br><span class="line">        print(&quot;Illegal character &#39;%s&#39;&quot; % t.value[0])</span><br><span class="line">        t.lexer.skip(1)</span><br><span class="line">    # Build the lexer</span><br><span class="line">    def build(self,**kwargs):</span><br><span class="line">        self.lexer &#x3D; lex.lex(module&#x3D;self, **kwargs)</span><br><span class="line">    </span><br><span class="line">    # Test it output</span><br><span class="line">    def test(self,data):</span><br><span class="line">        self.lexer.input(data)</span><br><span class="line">        while True:</span><br><span class="line">             tok &#x3D; self.lexer.token()</span><br><span class="line">             if not tok: break</span><br><span class="line">             print(tok)</span><br><span class="line"># Build the lexer and try it out</span><br><span class="line">m &#x3D; MyLexer()</span><br><span class="line">m.build()           # Build the lexer</span><br><span class="line">m.test(&quot;3 + 4&quot;)     # Test it</span><br></pre></td></tr></table></figure><br>当从类中定义 lexer，你需要创建类的实例，而不是类本身。这是因为，lexer 的方法只有被绑定（bound-methods）对象后才能使 PLY 正常工作。<br>当给 lex() 方法使用 module 选项时，PLY 使用dir()方法，从对象中获取符号信息，因为不能直接访问对象的<strong>dict</strong>属性。（译者注：可能是因为兼容性原因，<strong>dict</strong>这个方法可能不存在）</p>
<p>最后，如果你希望保持较好的封装性，但不希望什么东西都写在类里面，lexers 可以在闭包中定义，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import ply.lex as lex</span><br><span class="line"></span><br><span class="line"># List of token names.   This is always required</span><br><span class="line">tokens &#x3D; (</span><br><span class="line">  &#39;NUMBER&#39;,</span><br><span class="line">  &#39;PLUS&#39;,</span><br><span class="line">  &#39;MINUS&#39;,</span><br><span class="line">  &#39;TIMES&#39;,</span><br><span class="line">  &#39;DIVIDE&#39;,</span><br><span class="line">  &#39;LPAREN&#39;,</span><br><span class="line">  &#39;RPAREN&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def MyLexer():</span><br><span class="line">    # Regular expression rules for simple tokens</span><br><span class="line">    t_PLUS    &#x3D; r&#39;\+&#39;</span><br><span class="line">    t_MINUS   &#x3D; r&#39;-&#39;</span><br><span class="line">    t_TIMES   &#x3D; r&#39;\*&#39;</span><br><span class="line">    t_DIVIDE  &#x3D; r&#39;&#x2F;&#39;</span><br><span class="line">    t_LPAREN  &#x3D; r&#39;\(&#39;</span><br><span class="line">    t_RPAREN  &#x3D; r&#39;\)&#39;</span><br><span class="line"></span><br><span class="line">    # A regular expression rule with some action code</span><br><span class="line">    def t_NUMBER(t):</span><br><span class="line">        r&#39;\d+&#39;</span><br><span class="line">        t.value &#x3D; int(t.value)    </span><br><span class="line">        return t</span><br><span class="line"></span><br><span class="line">    # Define a rule so we can track line numbers</span><br><span class="line">    def t_newline(t):</span><br><span class="line">        r&#39;\n+&#39;</span><br><span class="line">        t.lexer.lineno +&#x3D; len(t.value)</span><br><span class="line"></span><br><span class="line">    # A string containing ignored characters (spaces and tabs)</span><br><span class="line">    t_ignore  &#x3D; &#39; \t&#39;</span><br><span class="line"></span><br><span class="line">    # Error handling rule</span><br><span class="line">    def t_error(t):</span><br><span class="line">        print &quot;Illegal character &#39;%s&#39;&quot; % t.value[0]</span><br><span class="line">        t.lexer.skip(1)</span><br><span class="line"></span><br><span class="line">    # Build the lexer from my environment and return it    </span><br><span class="line">    return lex.lex()</span><br></pre></td></tr></table></figure>
<h3 id="额外状态维护"><a href="#额外状态维护" class="headerlink" title="额外状态维护"></a>额外状态维护</h3><p>在你的词法分析器中，你可能想要维护一些状态。这可能包括模式设置，符号表和其他细节。例如，假设你想要跟踪NUMBER标记的出现个数。</p>
<p>一种方法是维护一个全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num_count &#x3D; 0</span><br><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;\d+&#39;</span><br><span class="line">    global num_count</span><br><span class="line">    num_count +&#x3D; 1</span><br><span class="line">    t.value &#x3D; int(t.value)    </span><br><span class="line">    return t</span><br></pre></td></tr></table></figure>
<p>如果你不喜欢全局变量，另一个记录信息的地方是 lexer 对象内部。可以通过当前标记的 lexer 属性访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;\d+&#39;</span><br><span class="line">    t.lexer.num_count +&#x3D; 1     # Note use of lexer attribute</span><br><span class="line">    t.value &#x3D; int(t.value)    </span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">lexer &#x3D; lex.lex()</span><br><span class="line">lexer.num_count &#x3D; 0            # Set the initial count</span><br></pre></td></tr></table></figure><br>上面这样做的优点是当同时存在多个 lexer 实例的情况下，简单易行。不过这看上去似乎是严重违反了面向对象的封装原则。lexer 的内部属性（除了 lineno ）都是以 lex 开头命名的（lexdata、lexpos）。因此，只要不以 lex 开头来命名属性就很安全的。<br>如果你不喜欢给 lexer 对象赋值，你可以自定义你的 lexer 类型，就像前面看到的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyLexer:</span><br><span class="line">    ...</span><br><span class="line">    def t_NUMBER(self,t):</span><br><span class="line">        r&#39;\d+&#39;</span><br><span class="line">        self.num_count +&#x3D; 1</span><br><span class="line">        t.value &#x3D; int(t.value)    </span><br><span class="line">        return t</span><br><span class="line"></span><br><span class="line">    def build(self, **kwargs):</span><br><span class="line">        self.lexer &#x3D; lex.lex(object&#x3D;self,**kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.num_count &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>如果你的应用会创建很多 lexer 的实例，并且需要维护很多状态，上面的类可能是最容易管理的。<br>状态也可以用闭包来管理，比如，在 Python3 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def MyLexer():</span><br><span class="line">    num_count &#x3D; 0</span><br><span class="line">    ...</span><br><span class="line">    def t_NUMBER(t):</span><br><span class="line">        r&#39;\d+&#39;</span><br><span class="line">        nonlocal num_count</span><br><span class="line">        num_count +&#x3D; 1</span><br><span class="line">        t.value &#x3D; int(t.value)    </span><br><span class="line">        return t</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="Lexer-克隆"><a href="#Lexer-克隆" class="headerlink" title="Lexer 克隆"></a>Lexer 克隆</h3><p>如果有必要的话，lexer 对象可以通过clone()方法来复制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lexer &#x3D; lex.lex()</span><br><span class="line">...</span><br><span class="line">newlexer &#x3D; lexer.clone()</span><br></pre></td></tr></table></figure>
<p>当 lexer 被克隆后，复制品能够精确的保留输入串和内部状态，不过，新的 lexer 可以接受一个不同的输出字串，并独立运作起来。这在几种情况下也许有用：当你在编写的解析器或编译器涉及到递归或者回退处理时，你需要扫描先前的部分，你可以clone并使用复制品，或者你在实现某种预编译处理，可以 clone 一些 lexer 来处理不同的输入文件。<br>创建克隆跟重新调用 lex.lex() 的不同点在于，PLY 不会重新构建任何的内部分析表或者正则式。当 lexer 是用类或者闭包创建的，需要注意类或闭包本身的的状态。换句话说你要注意新创建的 lexer 会共享原始 lexer 的这些状态，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D; MyLexer()</span><br><span class="line">a &#x3D; lex.lex(object&#x3D;m)      # Create a lexer</span><br><span class="line"></span><br><span class="line">b &#x3D; a.clone()              # Clone the lexer</span><br></pre></td></tr></table></figure>
<h3 id="Lexer-的内部状态"><a href="#Lexer-的内部状态" class="headerlink" title="Lexer 的内部状态"></a>Lexer 的内部状态</h3><p>lexer 有一些内部属性在特定情况下有用：</p>
<ul>
<li>lexer.lexpos。这是一个表示当前分析点的位置的整型值。如果你修改这个值的话，这会改变下一个 token() 的调用行为。在标记的规则方法里面，这个值表示紧跟匹配字串后面的第一个字符的位置，如果这个值在规则中修改，下一个返回的标记将从新的位置开始匹配</li>
<li>lexer.lineno。表示当前行号。PLY 只是声明这个属性的存在，却永远不更新这个值。如果你想要跟踪行号的话，你需要自己添加代码（ 4.6 行号和位置信息）</li>
<li>lexer.lexdata。当前 lexer 的输入字串，这个字符串就是 input() 方法的输入字串，更改它可能是个糟糕的做法，除非你知道自己在干什么。</li>
<li>lexer.lexmatch。PLY 内部调用 Python 的 re.match() 方法得到的当前标记的原始的 Match 对象，该对象被保存在这个属性中。如果你的正则式中包含分组的话，你可以通过这个对象获得这些分组的值。注意：这个属性只在有标记规则定义的方法中才有效。<h3 id="基于条件的扫描和启动条件"><a href="#基于条件的扫描和启动条件" class="headerlink" title="基于条件的扫描和启动条件"></a>基于条件的扫描和启动条件</h3>在高级的分析器应用程序中，使用状态化的词法扫描是很有用的。比如，你想在出现特定标记或句子结构的时候触发开始一个不同的词法分析逻辑。PLY 允许 lexer 在不同的状态之间转换。每个状态可以包含一些自己独特的标记和规则等。这是基于 GNU flex 的“启动条件”来实现的，关于 flex 详见 <a href="http://flex.sourceforge.net/manual/Start-Conditions.html#Start-Conditions" target="_blank" rel="noopener">http://flex.sourceforge.net/manual/Start-Conditions.html#Start-Conditions</a></li>
</ul>
<p>要使用 lex 的状态，你必须首先声明。通过在 lex 模块中声明”states”来做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">states &#x3D; (</span><br><span class="line">   (&#39;foo&#39;,&#39;exclusive&#39;),</span><br><span class="line">   (&#39;bar&#39;,&#39;inclusive&#39;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个声明中包含有两个状态：’foo’和’bar’。状态可以有两种类型：’排他型’和’包容型’。排他型的状态会使得 lexer 的行为发生完全的改变：只有能够匹配在这个状态下定义的规则的标记才会返回；包容型状态会将定义在这个状态下的规则添加到默认的规则集中，进而，只要能匹配这个规则集的标记都会返回。<br>一旦声明好之后，标记规则的命名需要包含状态名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t_foo_NUMBER &#x3D; r&#39;\d+&#39;                      # Token &#39;NUMBER&#39; in state &#39;foo&#39;        </span><br><span class="line">t_bar_ID     &#x3D; r&#39;[a-zA-Z_][a-zA-Z0-9_]*&#39;   # Token &#39;ID&#39; in state &#39;bar&#39;</span><br><span class="line"></span><br><span class="line">def t_foo_newline(t):</span><br><span class="line">    r&#39;\n&#39;</span><br><span class="line">    t.lexer.lineno +&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>一个标记可以用在多个状态中，只要将多个状态名包含在声明中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_foo_bar_NUMBER &#x3D; r&#39;\d+&#39;         # Defines token &#39;NUMBER&#39; in both state &#39;foo&#39; and &#39;bar&#39;</span><br></pre></td></tr></table></figure><br>同样的，在任何状态下都生效的声明可以在命名中使用ANY：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_ANY_NUMBER &#x3D; r&#39;\d+&#39;         # Defines a token &#39;NUMBER&#39; in all states</span><br></pre></td></tr></table></figure><br>不包含状态名的情况下，标记被关联到一个特殊的状态INITIAL，比如，下面两个声明是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t_NUMBER &#x3D; r&#39;\d+&#39;</span><br><span class="line">t_INITIAL_NUMBER &#x3D; r&#39;\d+&#39;</span><br></pre></td></tr></table></figure><br>特殊的t_ignore()和t_error()也可以用状态关联：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_foo_ignore &#x3D; &quot; \t\n&quot;       # Ignored characters for state &#39;foo&#39;</span><br><span class="line">def t_bar_error(t):          # Special error handler for state &#39;bar&#39;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><br>词法分析默认在INITIAL状态下工作，这个状态下包含了所有默认的标记规则定义。对于不希望使用“状态”的用户来说，这是完全透明的。在分析过程中，如果你想要改变词法分析器的这种的状态，使用begin()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def t_begin_foo(t):</span><br><span class="line">    r&#39;start_foo&#39;</span><br><span class="line">    t.lexer.begin(&#39;foo&#39;)             # Starts &#39;foo&#39; state</span><br></pre></td></tr></table></figure><br>使用 begin() 切换回初始状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def t_foo_end(t):</span><br><span class="line">    r&#39;end_foo&#39;</span><br><span class="line">    t.lexer.begin(&#39;INITIAL&#39;)        # Back to the initial state</span><br></pre></td></tr></table></figure><br>状态的切换可以使用栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def t_begin_foo(t):</span><br><span class="line">    r&#39;start_foo&#39;</span><br><span class="line">    t.lexer.push_state(&#39;foo&#39;)             # Starts &#39;foo&#39; state</span><br><span class="line"></span><br><span class="line">def t_foo_end(t):</span><br><span class="line">    r&#39;end_foo&#39;</span><br><span class="line">    t.lexer.pop_state()                   # Back to the previous state</span><br></pre></td></tr></table></figure><br>当你在面临很多状态可以选择进入，而又仅仅想要回到之前的状态时，状态栈比较有用。<br>举个例子会更清晰。假设你在写一个分析器想要从一堆 C 代码中获取任意匹配的闭合的大括号里面的部分：这意味着，当遇到起始括号’{‘，你需要读取与之匹配的’}’以上的所有部分。并返回字符串。使用通常的正则表达式几乎不可能，这是因为大括号可以嵌套，而且可以有注释，字符串等干扰。因此，试图简单的匹配第一个出现的’}’是不行的。这里你可以用lex的状态来做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># Declare the state</span><br><span class="line">states &#x3D; (</span><br><span class="line">  (&#39;ccode&#39;,&#39;exclusive&#39;),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Match the first &#123;. Enter ccode state.</span><br><span class="line">def t_ccode(t):</span><br><span class="line">    r&#39;\&#123;&#39;</span><br><span class="line">    t.lexer.code_start &#x3D; t.lexer.lexpos        # Record the starting position</span><br><span class="line">    t.lexer.level &#x3D; 1                          # Initial brace level</span><br><span class="line">    t.lexer.begin(&#39;ccode&#39;)                     # Enter &#39;ccode&#39; state</span><br><span class="line"></span><br><span class="line"># Rules for the ccode state</span><br><span class="line">def t_ccode_lbrace(t):     </span><br><span class="line">    r&#39;\&#123;&#39;</span><br><span class="line">    t.lexer.level +&#x3D;1                </span><br><span class="line"></span><br><span class="line">def t_ccode_rbrace(t):</span><br><span class="line">    r&#39;\&#125;&#39;</span><br><span class="line">    t.lexer.level -&#x3D;1</span><br><span class="line"></span><br><span class="line">    # If closing brace, return the code fragment</span><br><span class="line">    if t.lexer.level &#x3D;&#x3D; 0:</span><br><span class="line">         t.value &#x3D; t.lexer.lexdata[t.lexer.code_start:t.lexer.lexpos+1]</span><br><span class="line">         t.type &#x3D; &quot;CCODE&quot;</span><br><span class="line">         t.lexer.lineno +&#x3D; t.value.count(&#39;\n&#39;)</span><br><span class="line">         t.lexer.begin(&#39;INITIAL&#39;)           </span><br><span class="line">         return t</span><br><span class="line"></span><br><span class="line"># C or C++ comment (ignore)    </span><br><span class="line">def t_ccode_comment(t):</span><br><span class="line">    r&#39;(&#x2F;\*(.|\n)*?*&#x2F;)|(&#x2F;&#x2F;.*)&#39;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># C string</span><br><span class="line">def t_ccode_string(t):</span><br><span class="line">   r&#39;\&quot;([^\\\n]|(\\.))*?\&quot;&#39;</span><br><span class="line"></span><br><span class="line"># C character literal</span><br><span class="line">def t_ccode_char(t):</span><br><span class="line">   r&#39;\&#39;([^\\\n]|(\\.))*?\&#39;&#39;</span><br><span class="line"></span><br><span class="line"># Any sequence of non-whitespace characters (not braces, strings)</span><br><span class="line">def t_ccode_nonspace(t):</span><br><span class="line">   r&#39;[^\s\&#123;\&#125;\&#39;\&quot;]+&#39;</span><br><span class="line"></span><br><span class="line"># Ignored characters (whitespace)</span><br><span class="line">t_ccode_ignore &#x3D; &quot; \t\n&quot;</span><br><span class="line"></span><br><span class="line"># For bad characters, we just skip over it</span><br><span class="line">def t_ccode_error(t):</span><br></pre></td></tr></table></figure>
<pre><code>t.lexer.skip(1)
</code></pre><p>这个例子中，第一个’{‘使得 lexer 记录了起始位置，并且进入新的状态’ccode’。一系列规则用来匹配接下来的输入，这些规则只是丢弃掉标记（不返回值），如果遇到闭合右括号，t_ccode_rbrace 规则收集其中所有的代码（利用先前记录的开始位置），并保存，返回的标记类型为’CCODE’，与此同时，词法分析的状态退回到初始状态。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>lexer 需要输入的是一个字符串。好在大多数机器都有足够的内存，这很少导致性能的问题。这意味着，lexer 现在还不能用来处理文件流或者 socket 流。这主要是受到 re 模块的限制。</li>
<li>lexer 支持用 Unicode 字符描述标记的匹配规则，也支持输入字串包含 Unicode</li>
<li>如果你想要向re.compile()方法提供 flag，使用 reflags 选项：lex.lex(reflags=re.UNICODE)</li>
<li>由于 lexer 是全部用 Python 写的，性能很大程度上取决于 Python 的 re 模块，即使已经尽可能的高效了。当接收极其大量的输入文件时表现并不尽人意。如果担忧性能，你可以升级到最新的 Python，或者手工创建分析器，或者用 C 语言写 lexer 并做成扩展模块。</li>
</ul>
<p>如果你要创建一个手写的词法分析器并计划用在 yacc.py 中，只需要满足下面的要求：</p>
<ul>
<li>需要提供一个 token() 方法来返回下一个标记，如果没有可用的标记了，则返回 None。</li>
<li>token() 方法必须返回一个 tok 对象，具有 type 和 valu e属性。如果行号需要跟踪的话，标记还需要定义 lineno 属性。<h2 id="语法分析基础"><a href="#语法分析基础" class="headerlink" title="语法分析基础"></a>语法分析基础</h2>‘语法’通常用 BNF 范式来表达。例如，如果想要分析简单的算术表达式，你应该首先写下无二义的文法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">expression : expression + term</span><br><span class="line">           | expression - term</span><br><span class="line">           | term</span><br><span class="line"></span><br><span class="line">term       : term * factor</span><br><span class="line">           | term &#x2F; factor</span><br><span class="line">           | factor</span><br><span class="line"></span><br><span class="line">factor     : NUMBER</span><br><span class="line">           | ( expression )</span><br></pre></td></tr></table></figure>
<p>在这个文法中，像NUMBER,+,-,*,/的符号被称为终结符，对应原始的输入。类似term，factor等称为非终结符，它们由一系列终结符或其他规则的符号组成，用来指代语法规则。<br>通常使用一种叫语法制导翻译的技术来指定某种语言的语义。在语法制导翻译中，符号及其属性出现在每个语法规则后面的动作中。每当一个语法被识别，动作就能够描述需要做什么。比如，对于上面给定的文法，想要实现一个简单的计算器，应该写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Grammar                             Action</span><br><span class="line">--------------------------------    -------------------------------------------- </span><br><span class="line">expression0 : expression1 + term    expression0.val &#x3D; expression1.val + term.val</span><br><span class="line">            | expression1 - term    expression0.val &#x3D; expression1.val - term.val</span><br><span class="line">            | term                  expression0.val &#x3D; term.val</span><br><span class="line"></span><br><span class="line">term0       : term1 * factor        term0.val &#x3D; term1.val * factor.val</span><br><span class="line">            | term1 &#x2F; factor        term0.val &#x3D; term1.val &#x2F; factor.val</span><br><span class="line">            | factor                term0.val &#x3D; factor.val</span><br><span class="line"></span><br><span class="line">factor      : NUMBER                factor.val &#x3D; int(NUMBER.lexval)</span><br></pre></td></tr></table></figure>
<pre><code>        | ( expression )        factor.val = expression.val
</code></pre><p>一种理解语法指导翻译的好方法是将符号看成对象。与符号相关的值代表了符号的“状态”（比如上面的 val 属性），语义行为用一组操作符号及符号值的函数或者方法来表达。<br>Yacc 用的分析技术是著名的 LR 分析法或者叫移进-归约分析法。LR 分析法是一种自下而上的技术：首先尝试识别右部的语法规则，每当右部得到满足，相应的行为代码将被触发执行，当前右边的语法符号将被替换为左边的语法符号。（归约）</p>
<p>LR 分析法一般这样实现：将下一个符号进栈，然后结合栈顶的符号和后继符号（译者注：下一个将要输入符号），与文法中的某种规则相比较。具体的算法可以在编译器的手册中查到，下面的例子展现了如果通过上面定义的文法，来分析 3 + 5 * ( 10 - 20 ) 这个表达式，$ 用来表示输入结束，action 里面的 Shift 就是进栈动作，简称移进；Reduce 是归约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Step Symbol Stack           Input Tokens            Action</span><br><span class="line">---- ---------------------  ---------------------   -------------------------------</span><br><span class="line">1                           3 + 5 * ( 10 - 20 )$    Shift 3</span><br><span class="line">2    3                        + 5 * ( 10 - 20 )$    Reduce factor : NUMBER</span><br><span class="line">3    factor                   + 5 * ( 10 - 20 )$    Reduce term   : factor</span><br><span class="line">4    term                     + 5 * ( 10 - 20 )$    Reduce expr : term</span><br><span class="line">5    expr                     + 5 * ( 10 - 20 )$    Shift +</span><br><span class="line">6    expr +                     5 * ( 10 - 20 )$    Shift 5</span><br><span class="line">7    expr + 5                     * ( 10 - 20 )$    Reduce factor : NUMBER</span><br><span class="line">8    expr + factor                * ( 10 - 20 )$    Reduce term   : factor</span><br><span class="line">9    expr + term                  * ( 10 - 20 )$    Shift *</span><br><span class="line">10   expr + term *                  ( 10 - 20 )$    Shift (</span><br><span class="line">11   expr + term * (                  10 - 20 )$    Shift 10</span><br><span class="line">12   expr + term * ( 10                  - 20 )$    Reduce factor : NUMBER</span><br><span class="line">13   expr + term * ( factor              - 20 )$    Reduce term : factor</span><br><span class="line">14   expr + term * ( term                - 20 )$    Reduce expr : term</span><br><span class="line">15   expr + term * ( expr                - 20 )$    Shift -</span><br><span class="line">16   expr + term * ( expr -                20 )$    Shift 20</span><br><span class="line">17   expr + term * ( expr - 20                )$    Reduce factor : NUMBER</span><br><span class="line">18   expr + term * ( expr - factor            )$    Reduce term : factor</span><br><span class="line">19   expr + term * ( expr - term              )$    Reduce expr : expr - term</span><br><span class="line">20   expr + term * ( expr                     )$    Shift )</span><br><span class="line">21   expr + term * ( expr )                    $    Reduce factor : (expr)</span><br><span class="line">22   expr + term * factor                      $    Reduce term : term * factor</span><br><span class="line">23   expr + term                               $    Reduce expr : expr + term</span><br><span class="line">24   expr                                      $    Reduce expr</span><br></pre></td></tr></table></figure>
<p>25                                             $    Success!</p>
<p>在分析表达式的过程中，一个相关的自动状态机和后继符号决定了下一步应该做什么。如果下一个标记看起来是一个有效语法（产生式）的一部分（通过栈上的其他项判断这一点），那么这个标记应该进栈。如果栈顶的项可以组成一个完整的右部语法规则，一般就可以进行“归约”，用产生式左边的符号代替这一组符号。当归约发生时，相应的行为动作就会执行。如果输入标记既不能移进也不能归约的话，就会发生语法错误，分析器必须进行相应的错误恢复。分析器直到栈空并且没有另外的输入标记时，才算成功。 需要注意的是，这是基于一个有限自动机实现的，有限自动器被转化成分析表。分析表的构建比较复杂，超出了本文的讨论范围。不过，这构建过程的微妙细节能够解释为什么在上面的例子中，解析器选择在步骤 9 将标记转移到堆栈中，而不是按照规则 expr : expr + term 做归约。</p>
<h2 id="Yacc简介"><a href="#Yacc简介" class="headerlink" title="Yacc简介"></a>Yacc简介</h2><p>ply.yacc 模块实现了 PLY 的分析功能，‘yacc’是‘Yet Another Compiler Compiler’的缩写并保留了其作为 Unix 工具的名字。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>假设你希望实现上面的简单算术表达式的语法分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># Yacc example</span><br><span class="line"></span><br><span class="line">import ply.yacc as yacc</span><br><span class="line"></span><br><span class="line"># Get the token map from the lexer.  This is required.</span><br><span class="line">from calclex import tokens</span><br><span class="line"></span><br><span class="line">def p_expression_plus(p):</span><br><span class="line">    &#39;expression : expression PLUS term&#39;</span><br><span class="line">    p[0] &#x3D; p[1] + p[3]</span><br><span class="line"></span><br><span class="line">def p_expression_minus(p):</span><br><span class="line">    &#39;expression : expression MINUS term&#39;</span><br><span class="line">    p[0] &#x3D; p[1] - p[3]</span><br><span class="line"></span><br><span class="line">def p_expression_term(p):</span><br><span class="line">    &#39;expression : term&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line"></span><br><span class="line">def p_term_times(p):</span><br><span class="line">    &#39;term : term TIMES factor&#39;</span><br><span class="line">    p[0] &#x3D; p[1] * p[3]</span><br><span class="line"></span><br><span class="line">def p_term_div(p):</span><br><span class="line">    &#39;term : term DIVIDE factor&#39;</span><br><span class="line">    p[0] &#x3D; p[1] &#x2F; p[3]</span><br><span class="line"></span><br><span class="line">def p_term_factor(p):</span><br><span class="line">    &#39;term : factor&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line"></span><br><span class="line">def p_factor_num(p):</span><br><span class="line">    &#39;factor : NUMBER&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line"></span><br><span class="line">def p_factor_expr(p):</span><br><span class="line">    &#39;factor : LPAREN expression RPAREN&#39;</span><br><span class="line">    p[0] &#x3D; p[2]</span><br><span class="line"></span><br><span class="line"># Error rule for syntax errors</span><br><span class="line">def p_error(p):</span><br><span class="line">    print &quot;Syntax error in input!&quot;</span><br><span class="line"></span><br><span class="line"># Build the parser</span><br><span class="line">parser &#x3D; yacc.yacc()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">   try:</span><br><span class="line">       s &#x3D; raw_input(&#39;calc &gt; &#39;)</span><br><span class="line">   except EOFError:</span><br><span class="line">       break</span><br><span class="line">   if not s: continue</span><br><span class="line">   result &#x3D; parser.parse(s)</span><br></pre></td></tr></table></figure>
<p>   print result</p>
<p>在这个例子中，每个语法规则被定义成一个 Python 的方法，方法的文档字符串描述了相应的上下文无关文法，方法的语句实现了对应规则的语义行为。每个方法接受一个单独的 p 参数，p 是一个包含有当前匹配语法的符号的序列，p[i] 与语法符号的对应关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def p_expression_plus(p):</span><br><span class="line">    &#39;expression : expression PLUS term&#39;</span><br><span class="line">    #   ^            ^        ^    ^</span><br><span class="line">    #  p[0]         p[1]     p[2] p[3]</span><br><span class="line"></span><br><span class="line">    p[0] &#x3D; p[1] + p[3]</span><br></pre></td></tr></table></figure><br>其中，p[i] 的值相当于词法分析模块中对 p.value 属性赋的值，对于非终结符的值，将在归约时由 p[0] 的赋值决定，这里的值可以是任何类型，当然，大多数情况下只是 Python 的简单类型、元组或者类的实例。在这个例子中，我们依赖这样一个事实：NUMBER 标记的值保存的是整型值，所有规则的行为都是得到这些整型值的算术运算结果，并传递结果。<br>在 yacc 中定义的第一个语法规则被默认为起始规则（这个例子中的第一个出现的 expression 规则）。一旦起始规则被分析器归约，而且再无其他输入，分析器终止，最后的值将返回（这个值将是起始规则的p[0]）。注意：也可以通过在 yacc() 中使用 start 关键字参数来指定起始规则。</p>
<p>p_error(p) 规则用于捕获语法错误。详见处理语法错误部分。</p>
<p>为了构建分析器，需要调用 yacc.yacc() 方法。这个方法查看整个当前模块，然后试图根据你提供的文法构建 LR 分析表。由于分析表的得出相对开销较大（尤其包含大量的语法的情况下），分析表被写入当前目录的一个叫 parsetab.py 的文件中。除此之外，会生成一个调试文件 parser.out。在接下来的执行中，yacc 直到发现文法发生变化，才会重新生成分析表和 parsetab.py 文件，否则 yacc 会从 parsetab.py 中加载分析表。注：如果有必要的话这里输出的文件名是可以改的。</p>
<p>如果在你的文法中有任何错误的话，yacc.py 会产生调试信息，而且可能抛出异常。一些可以被检测到的错误如下：</p>
<ul>
<li>方法重复定义（在语法文件中具有相同名字的方法）</li>
<li>二义文法产生的移进-归约和归约-归约冲突</li>
<li>指定了错误的文法</li>
<li>不可终止的递归（规则永远无法终结）</li>
<li>未使用的规则或标记</li>
<li>未定义的规则或标记</li>
</ul>
<p>这个例子的最后部分展示了如何执行由 yacc() 方法创建的分析器。你只需要简单的调用 parse()，并将输入字符串作为参数就能运行分析器。它将运行所有的语法规则，并返回整个分析的结果，这个结果就是在起始规则中赋给 p[0] 的值。</p>
<h3 id="将语法规则合并"><a href="#将语法规则合并" class="headerlink" title="将语法规则合并"></a>将语法规则合并</h3><p>如果语法规则类似的话，可以合并到一个方法中。例如，考虑前面例子中的两个规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def p_expression_plus(p):</span><br><span class="line">    &#39;expression : expression PLUS term&#39;</span><br><span class="line">    p[0] &#x3D; p[1] + p[3]</span><br><span class="line"></span><br><span class="line">def p_expression_minus(t):</span><br><span class="line">    &#39;expression : expression MINUS term&#39;</span><br><span class="line">    p[0] &#x3D; p[1] - p[3]</span><br></pre></td></tr></table></figure>
<p>比起写两个方法，你可以像下面这样写在一个方法里面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def p_expression(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression PLUS term</span><br><span class="line">                  | expression MINUS term&#39;&#39;&#39;</span><br><span class="line">    if p[2] &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] + p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] - p[3]</span><br></pre></td></tr></table></figure><br>总之，方法的文档字符串可以包含多个语法规则。所以，像这样写也是合法的（尽管可能会引起困惑）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def p_binary_operators(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression PLUS term</span><br><span class="line">                  | expression MINUS term</span><br><span class="line">       term       : term TIMES factor</span><br><span class="line">                  | term DIVIDE factor&#39;&#39;&#39;</span><br><span class="line">    if p[2] &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] + p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] - p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;*&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] * p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;&#x2F;&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] &#x2F; p[3]</span><br></pre></td></tr></table></figure><br>如果所有的规则都有相似的结构，那么将语法规则合并才是个不错的注意（比如，产生式的项数相同）。不然，语义动作可能会变得复杂。不过，简单情况下，可以使用len()方法区分，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def p_expressions(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression MINUS expression</span><br><span class="line">                  | MINUS expression&#39;&#39;&#39;</span><br><span class="line">    if (len(p) &#x3D;&#x3D; 4):</span><br><span class="line">        p[0] &#x3D; p[1] - p[3]</span><br><span class="line">    elif (len(p) &#x3D;&#x3D; 3):</span><br><span class="line">        p[0] &#x3D; -p[2]</span><br></pre></td></tr></table></figure><br>如果考虑解析的性能，你应该避免像这些例子一样在一个语法规则里面用很多条件来处理。因为，每次检查当前究竟匹配的是哪个语法规则的时候，实际上重复做了分析器已经做过的事（分析器已经准确的知道哪个规则被匹配了）。为每个规则定义单独的方法，可以消除这点开销。</p>
<h3 id="字面字符-1"><a href="#字面字符-1" class="headerlink" title="字面字符"></a>字面字符</h3><p>如果愿意，可以在语法规则里面使用单个的字面字符，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def p_binary_operators(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression &#39;+&#39; term</span><br><span class="line">                  | expression &#39;-&#39; term</span><br><span class="line">       term       : term &#39;*&#39; factor</span><br><span class="line">                  | term &#39;&#x2F;&#39; factor&#39;&#39;&#39;</span><br><span class="line">    if p[2] &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] + p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] - p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;*&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] * p[3]</span><br><span class="line">    elif p[2] &#x3D;&#x3D; &#39;&#x2F;&#39;:</span><br><span class="line">        p[0] &#x3D; p[1] &#x2F; p[3]</span><br></pre></td></tr></table></figure>
<p>字符必须像’+’那样使用单引号。除此之外，需要将用到的字符定义单独定义在 lex 文件的literals列表里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Literals.  Should be placed in module given to lex()</span><br><span class="line">literals &#x3D; [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;&#x2F;&#39; ]</span><br></pre></td></tr></table></figure><br>字面的字符只能是单个字符。因此，像’&lt;=’或者’==’都是不合法的，只能使用一般的词法规则（例如 t_EQ = r’==’)。</p>
<h3 id="空产生式"><a href="#空产生式" class="headerlink" title="空产生式"></a>空产生式</h3><p>yacc.py 可以处理空产生式，像下面这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_empty(p):</span><br><span class="line">    &#39;empty :&#39;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>现在可以使用空匹配，只要将’empty’当成一个符号使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def p_optitem(p):</span><br><span class="line">    &#39;optitem : item&#39;</span><br><span class="line">    &#39;        | empty&#39;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>注意：你可以将产生式保持’空’，来表示空匹配。然而，我发现用一个’empty’规则并用其来替代’空’，更容易表达意图，并有较好的可读性。</p>
<h3 id="改变起始符号"><a href="#改变起始符号" class="headerlink" title="改变起始符号"></a>改变起始符号</h3><p>默认情况下，在 yacc 中的第一条规则是起始语法规则（顶层规则）。可以用 start 标识来改变这种行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start &#x3D; &#39;foo&#39;</span><br><span class="line">def p_bar(p):</span><br><span class="line">    &#39;bar : A B&#39;</span><br><span class="line"></span><br><span class="line"># This is the starting rule due to the start specifier above</span><br><span class="line">def p_foo(p):</span><br><span class="line">    &#39;foo : bar X&#39;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>用 start 标识有助于在调试的时候将大型的语法规则分成小部分来分析。也可把 start 符号作为yacc的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yacc.yacc(start&#x3D;&#39;foo&#39;)</span><br></pre></td></tr></table></figure></p>
<h3 id="处理二义文法"><a href="#处理二义文法" class="headerlink" title="处理二义文法"></a>处理二义文法</h3><p>上面例子中，对表达式的文法描述用一种特别的形式规避了二义文法。然而，在很多情况下，这样的特殊文法很难写，或者很别扭。一个更为自然和舒服的语法表达应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expression : expression PLUS expression</span><br><span class="line">           | expression MINUS expression</span><br><span class="line">           | expression TIMES expression</span><br><span class="line">           | expression DIVIDE expression</span><br><span class="line">           | LPAREN expression RPAREN</span><br><span class="line">           | NUMBER</span><br></pre></td></tr></table></figure>
<p>不幸的是，这样的文法是存在二义性的。举个例子，如果你要解析字符串”3 <em> 4 + 5”，操作符如何分组并没有指明，究竟是表示”(3 </em> 4) + 5”还是”3 <em> (4 + 5)”呢？<br>如果在 yacc.py 中存在二义文法，会输出”移进归约冲突”或者”归约归约冲突”。在分析器无法确定是将下一个符号移进栈还是将当前栈中的符号归约时会产生移进归约冲突。例如，对于”3 </em> 4 + 5”，分析器内部栈是这样工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Step Symbol Stack           Input Tokens            Action</span><br><span class="line">---- ---------------------  ---------------------   -------------------------------</span><br><span class="line">1    $                                3 * 4 + 5$    Shift 3</span><br><span class="line">2    $ 3                                * 4 + 5$    Reduce : expression : NUMBER</span><br><span class="line">3    $ expr                             * 4 + 5$    Shift *</span><br><span class="line">4    $ expr *                             4 + 5$    Shift 4</span><br><span class="line">5    $ expr * 4                             + 5$    Reduce: expression : NUMBER</span><br><span class="line">6    $ expr * expr                          + 5$    SHIFT&#x2F;REDUCE CONFLICT ????</span><br></pre></td></tr></table></figure>
<p>两种选择对于上面的上下文无关文法而言都是合法的。<br>默认情况下，所有的移进归约冲突会倾向于使用移进来处理。因此，对于上面的例子，分析器总是会将’+’进栈，而不是做归约。虽然在很多情况下，这个策略是合适的（像”if-then”和”if-then-else”），但这对于算术表达式是不够的。事实上，对于上面的例子，将’+’进栈是完全错误的，应当先将expr * expr归约，因为乘法的优先级要高于加法。</p>
<p>为了解决二义文法，尤其是对表达式文法，yacc.py 允许为标记单独指定优先级和结合性。需要像下面这样增加一个 precedence 变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">precedence &#x3D; (</span><br><span class="line">    (&#39;left&#39;, &#39;PLUS&#39;, &#39;MINUS&#39;),</span><br><span class="line">    (&#39;left&#39;, &#39;TIMES&#39;, &#39;DIVIDE&#39;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样的定义说明 PLUS/MINUS 标记具有相同的优先级和左结合性，TIMES/DIVIDE 具有相同的优先级和左结合性。在 precedence 声明中，标记的优先级从低到高。因此，这个声明表明 TIMES/DIVIDE（他们较晚加入 precedence）的优先级高于 PLUS/MINUS。<br>由于为标记添加了数字表示的优先级和结合性的属性，所以，对于上面的例子，将会得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLUS      : level &#x3D; 1,  assoc &#x3D; &#39;left&#39;</span><br><span class="line">MINUS     : level &#x3D; 1,  assoc &#x3D; &#39;left&#39;</span><br><span class="line">TIMES     : level &#x3D; 2,  assoc &#x3D; &#39;left&#39;</span><br><span class="line">DIVIDE    : level &#x3D; 2,  assoc &#x3D; &#39;left&#39;</span><br></pre></td></tr></table></figure>
<p>随后这些值被附加到语法规则的优先级和结合性属性上，这些值由最右边的终结符的优先级和结合性决定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expression : expression PLUS expression                 # level &#x3D; 1, left</span><br><span class="line">           | expression MINUS expression                # level &#x3D; 1, left</span><br><span class="line">           | expression TIMES expression                # level &#x3D; 2, left</span><br><span class="line">           | expression DIVIDE expression               # level &#x3D; 2, left</span><br><span class="line">           | LPAREN expression RPAREN                   # level &#x3D; None (not specified)</span><br></pre></td></tr></table></figure><br>           | NUMBER                                     # level = None (not specified)</p>
<p>当出现移进归约冲突时，分析器生成器根据下面的规则解决二义文法：</p>
<ul>
<li>如果当前的标记的优先级高于栈顶规则的优先级，移进当前标记</li>
<li>如果栈顶规则的优先级更高，进行归约</li>
<li>如果当前的标记与栈顶规则的优先级相同，如果标记是左结合的，则归约，否则，如果是右结合的则移进</li>
<li>如果没有优先级可以参考，默认对于移进归约冲突执行移进</li>
</ul>
<p>比如，当解析到”expression PLUS expression”这个语法时，下一个标记是 TIMES，此时将执行移进，因为 TIMES 具有比 PLUS 更高的优先级；当解析到”expression TIMES expression”，下一个标记是 PLUS，此时将执行归约，因为 PLUS 的优先级低于 TIMES。</p>
<p>如果在使用前三种技术解决已经归约冲突后，yacc.py 将不会报告语法中的冲突或者错误（不过，会在 parser.out 这个调试文件中输出一些信息）。</p>
<p>使用 precedence 指定优先级的技术会带来一个问题，有时运算符的优先级需要基于上下文。例如，考虑”3 + 4 * -5”中的一元的’-‘。数学上讲，一元运算符应当拥有较高的优先级。然而，在我们的 precedence 定义中，MINUS 的优先级却低于 TIMES。为了解决这个问题，precedene 规则中可以包含”虚拟标记”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">precedence &#x3D; (</span><br><span class="line">    (&#39;left&#39;, &#39;PLUS&#39;, &#39;MINUS&#39;),</span><br><span class="line">    (&#39;left&#39;, &#39;TIMES&#39;, &#39;DIVIDE&#39;),</span><br><span class="line">    (&#39;right&#39;, &#39;UMINUS&#39;),            # Unary minus operator</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在语法文件中，我们可以这么表示一元算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_expr_uminus(p):</span><br><span class="line">    &#39;expression : MINUS expression %prec UMINUS&#39;</span><br><span class="line">    p[0] &#x3D; -p[2]</span><br></pre></td></tr></table></figure><br>在这个例子中，%prec UMINUS 覆盖了默认的优先级（MINUS 的优先级），将 UMINUS 指代的优先级应用在该语法规则上。<br>起初，UMINUS 标记的例子会让人感到困惑。UMINUS 既不是输入的标记也不是语法规则，你应当将其看成 precedence 表中的特殊的占位符。当你使用 %prec 宏时，你是在告诉 yacc，你希望表达式使用这个占位符所表示的优先级，而不是正常的优先级。</p>
<p>还可以在 precedence 表中指定”非关联”。这表明你不希望链式运算符。比如，假如你希望支持比较运算符’&lt;’和’&gt;’，但是你不希望支持 a &lt; b &lt; c，只要简单指定规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">precedence &#x3D; (</span><br><span class="line">    (&#39;nonassoc&#39;, &#39;LESSTHAN&#39;, &#39;GREATERTHAN&#39;),  # Nonassociative operators</span><br><span class="line">    (&#39;left&#39;, &#39;PLUS&#39;, &#39;MINUS&#39;),</span><br><span class="line">    (&#39;left&#39;, &#39;TIMES&#39;, &#39;DIVIDE&#39;),</span><br><span class="line">    (&#39;right&#39;, &#39;UMINUS&#39;),            # Unary minus operator</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此时，当输入形如 a &lt; b &lt; c 时，将产生语法错误，却不影响形如 a &lt; b 的表达式。<br>对于给定的符号集，存在多种语法规则可以匹配时会产生归约/归约冲突。这样的冲突往往很严重，而且总是通过匹配最早出现的语法规则来解决。归约/归约冲突几乎总是相同的符号集合具有不同的规则可以匹配，而在这一点上无法抉择，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assignment :  ID EQUALS NUMBER</span><br><span class="line">           |  ID EQUALS expression</span><br><span class="line">           </span><br><span class="line">expression : expression PLUS expression</span><br><span class="line">           | expression MINUS expression</span><br><span class="line">           | expression TIMES expression</span><br><span class="line">           | expression DIVIDE expression</span><br><span class="line">           | LPAREN expression RPAREN</span><br><span class="line">           | NUMBER</span><br></pre></td></tr></table></figure>
<p>这个例子中，对于下面这两条规则将产生归约/归约冲突：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assignment  : ID EQUALS NUMBER</span><br><span class="line">expression  : NUMBER</span><br></pre></td></tr></table></figure><br>比如，对于”a = 5”，分析器不知道应当按照 assignment : ID EQUALS NUMBER 归约，还是先将 5 归约成 expression，再归约成 assignment : ID EQUALS expression。<br>应当指出的是，只是简单的查看语法规则是很难减少归约/归约冲突。如果出现归约/归约冲突，yacc()会帮助打印出警告信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: 1 reduce&#x2F;reduce conflict</span><br><span class="line">WARNING: reduce&#x2F;reduce conflict in state 15 resolved using rule (assignment -&gt; ID EQUALS NUMBER)</span><br><span class="line">WARNING: rejected rule (expression -&gt; NUMBER)</span><br></pre></td></tr></table></figure>
<p>上面的信息标识出了冲突的两条规则，但是，并无法指出究竟在什么情况下会出现这样的状态。想要发现问题，你可能需要结合语法规则和parser.out调试文件的内容。</p>
<h3 id="parser-out调试文件"><a href="#parser-out调试文件" class="headerlink" title="parser.out调试文件"></a>parser.out调试文件</h3><p>使用 LR 分析算法跟踪移进/归约冲突和归约/归约冲突是件乐在其中的事。为了辅助调试，yacc.py 在生成分析表时会创建出一个调试文件叫 parser.out：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">Unused terminals:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Grammar</span><br><span class="line"></span><br><span class="line">Rule 1     expression -&gt; expression PLUS expression</span><br><span class="line">Rule 2     expression -&gt; expression MINUS expression</span><br><span class="line">Rule 3     expression -&gt; expression TIMES expression</span><br><span class="line">Rule 4     expression -&gt; expression DIVIDE expression</span><br><span class="line">Rule 5     expression -&gt; NUMBER</span><br><span class="line">Rule 6     expression -&gt; LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">Terminals, with rules where they appear</span><br><span class="line"></span><br><span class="line">TIMES                : 3</span><br><span class="line">error                : </span><br><span class="line">MINUS                : 2</span><br><span class="line">RPAREN               : 6</span><br><span class="line">LPAREN               : 6</span><br><span class="line">DIVIDE               : 4</span><br><span class="line">PLUS                 : 1</span><br><span class="line">NUMBER               : 5</span><br><span class="line"></span><br><span class="line">Nonterminals, with rules where they appear</span><br><span class="line"></span><br><span class="line">expression           : 1 1 2 2 3 3 4 4 6 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parsing method: LALR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 0</span><br><span class="line"></span><br><span class="line">    S&#39; -&gt; . expression</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 1</span><br><span class="line"></span><br><span class="line">    S&#39; -&gt; expression .</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    PLUS            shift and go to state 6</span><br><span class="line">    MINUS           shift and go to state 5</span><br><span class="line">    TIMES           shift and go to state 4</span><br><span class="line">    DIVIDE          shift and go to state 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 2</span><br><span class="line"></span><br><span class="line">    expression -&gt; LPAREN . expression RPAREN</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 3</span><br><span class="line"></span><br><span class="line">    expression -&gt; NUMBER .</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 5</span><br><span class="line">    PLUS            reduce using rule 5</span><br><span class="line">    MINUS           reduce using rule 5</span><br><span class="line">    TIMES           reduce using rule 5</span><br><span class="line">    DIVIDE          reduce using rule 5</span><br><span class="line">    RPAREN          reduce using rule 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 4</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression TIMES . expression</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 5</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression MINUS . expression</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 6</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression PLUS . expression</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 7</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression DIVIDE . expression</span><br><span class="line">    expression -&gt; . expression PLUS expression</span><br><span class="line">    expression -&gt; . expression MINUS expression</span><br><span class="line">    expression -&gt; . expression TIMES expression</span><br><span class="line">    expression -&gt; . expression DIVIDE expression</span><br><span class="line">    expression -&gt; . NUMBER</span><br><span class="line">    expression -&gt; . LPAREN expression RPAREN</span><br><span class="line"></span><br><span class="line">    NUMBER          shift and go to state 3</span><br><span class="line">    LPAREN          shift and go to state 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 8</span><br><span class="line"></span><br><span class="line">    expression -&gt; LPAREN expression . RPAREN</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    RPAREN          shift and go to state 13</span><br><span class="line">    PLUS            shift and go to state 6</span><br><span class="line">    MINUS           shift and go to state 5</span><br><span class="line">    TIMES           shift and go to state 4</span><br><span class="line">    DIVIDE          shift and go to state 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state 9</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression TIMES expression .</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 3</span><br><span class="line">    PLUS            reduce using rule 3</span><br><span class="line">    MINUS           reduce using rule 3</span><br><span class="line">    TIMES           reduce using rule 3</span><br><span class="line">    DIVIDE          reduce using rule 3</span><br><span class="line">    RPAREN          reduce using rule 3</span><br><span class="line"></span><br><span class="line">  ! PLUS            [ shift and go to state 6 ]</span><br><span class="line">  ! MINUS           [ shift and go to state 5 ]</span><br><span class="line">  ! TIMES           [ shift and go to state 4 ]</span><br><span class="line">  ! DIVIDE          [ shift and go to state 7 ]</span><br><span class="line"></span><br><span class="line">state 10</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression MINUS expression .</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 2</span><br><span class="line">    PLUS            reduce using rule 2</span><br><span class="line">    MINUS           reduce using rule 2</span><br><span class="line">    RPAREN          reduce using rule 2</span><br><span class="line">    TIMES           shift and go to state 4</span><br><span class="line">    DIVIDE          shift and go to state 7</span><br><span class="line"></span><br><span class="line">  ! TIMES           [ reduce using rule 2 ]</span><br><span class="line">  ! DIVIDE          [ reduce using rule 2 ]</span><br><span class="line">  ! PLUS            [ shift and go to state 6 ]</span><br><span class="line">  ! MINUS           [ shift and go to state 5 ]</span><br><span class="line"></span><br><span class="line">state 11</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression PLUS expression .</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 1</span><br><span class="line">    PLUS            reduce using rule 1</span><br><span class="line">    MINUS           reduce using rule 1</span><br><span class="line">    RPAREN          reduce using rule 1</span><br><span class="line">    TIMES           shift and go to state 4</span><br><span class="line">    DIVIDE          shift and go to state 7</span><br><span class="line"></span><br><span class="line">  ! TIMES           [ reduce using rule 1 ]</span><br><span class="line">  ! DIVIDE          [ reduce using rule 1 ]</span><br><span class="line">  ! PLUS            [ shift and go to state 6 ]</span><br><span class="line">  ! MINUS           [ shift and go to state 5 ]</span><br><span class="line"></span><br><span class="line">state 12</span><br><span class="line"></span><br><span class="line">    expression -&gt; expression DIVIDE expression .</span><br><span class="line">    expression -&gt; expression . PLUS expression</span><br><span class="line">    expression -&gt; expression . MINUS expression</span><br><span class="line">    expression -&gt; expression . TIMES expression</span><br><span class="line">    expression -&gt; expression . DIVIDE expression</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 4</span><br><span class="line">    PLUS            reduce using rule 4</span><br><span class="line">    MINUS           reduce using rule 4</span><br><span class="line">    TIMES           reduce using rule 4</span><br><span class="line">    DIVIDE          reduce using rule 4</span><br><span class="line">    RPAREN          reduce using rule 4</span><br><span class="line"></span><br><span class="line">  ! PLUS            [ shift and go to state 6 ]</span><br><span class="line">  ! MINUS           [ shift and go to state 5 ]</span><br><span class="line">  ! TIMES           [ shift and go to state 4 ]</span><br><span class="line">  ! DIVIDE          [ shift and go to state 7 ]</span><br><span class="line"></span><br><span class="line">state 13</span><br><span class="line"></span><br><span class="line">    expression -&gt; LPAREN expression RPAREN .</span><br><span class="line"></span><br><span class="line">    $               reduce using rule 6</span><br><span class="line">    PLUS            reduce using rule 6</span><br><span class="line">    MINUS           reduce using rule 6</span><br><span class="line">    TIMES           reduce using rule 6</span><br><span class="line">    DIVIDE          reduce using rule 6</span><br></pre></td></tr></table></figure>
<pre><code>RPAREN          reduce using rule 6
</code></pre><p>文件中出现的不同状态，代表了有效输入标记的所有可能的组合，这是依据文法规则得到的。当得到输入标记时，分析器将构造一个栈，并找到匹配的规则。每个状态跟踪了当前输入进行到语法规则中的哪个位置，在每个规则中，’.’表示当前分析到规则的哪个位置，而且，对于在当前状态下，输入的每个有效标记导致的动作也被罗列出来。当出现移进/归约或归约/归约冲突时，被忽略的规则前面会添加!，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">! TIMES           [ reduce using rule 2 ]</span><br><span class="line">  ! DIVIDE          [ reduce using rule 2 ]</span><br><span class="line">  ! PLUS            [ shift and go to state 6 ]</span><br><span class="line">  ! MINUS           [ shift and go to state 5 ]</span><br></pre></td></tr></table></figure>
<p>通过查看这些规则并结合一些实例，通常能够找到大部分冲突的根源。应该强调的是，不是所有的移进归约冲突都是不好的，想要确定解决方法是否正确，唯一的办法就是查看 parser.out。</p>
<h3 id="处理语法错误"><a href="#处理语法错误" class="headerlink" title="处理语法错误"></a>处理语法错误</h3><p>如果你创建的分析器用于产品，处理语法错误是很重要的。一般而言，你不希望分析器在遇到错误的时候就抛出异常并终止，相反，你需要它报告错误，尽可能的恢复并继续分析，一次性的将输入中所有的错误报告给用户。这是一些已知语言编译器的标准行为，例如 C,C++,Java。在 PLY 中，在语法分析过程中出现错误，错误会被立即检测到（分析器不会继续读取源文件中错误点后面的标记）。然而，这时，分析器会进入恢复模式，这个模式能够用来尝试继续向下分析。LR 分析器的错误恢复是个理论与技巧兼备的问题，yacc.py 提供的错误机制与 Unix 下的 yacc 类似，所以你可以从诸如 O’Reilly 出版的《Lex and yacc》的书中找到更多的细节。</p>
<p>当错误发生时，yacc.py 按照如下步骤进行：</p>
<ul>
<li>第一次错误产生时，用户定义的 p_error()方法会被调用，出错的标记会作为参数传入；如果错误是因为到达文件结尾造成的，传入的参数将为 None。随后，分析器进入到“错误恢复”模式，该模式下不会在产生p_error()调用，直到它成功的移进 3 个标记，然后回归到正常模式。</li>
<li>如果在 p_error() 中没有指定恢复动作的话，这个导致错误的标记会被替换成一个特殊的 error 标记。</li>
<li>如果导致错误的标记已经是 error 的话，原先的栈顶的标记将被移除。</li>
<li>如果整个分析栈被放弃，分析器会进入重置状态，并从他的初始状态开始分析。</li>
<li>如果此时的语法规则接受 error 标记，error 标记会移进栈。</li>
<li>如果当前栈顶是 error 标记，之后的标记将被忽略，直到有标记能够导致 error 的归约。<ul>
<li>根据 error 规则恢复和再同步</li>
</ul>
</li>
</ul>
<p>最佳的处理语法错误的做法是在语法规则中包含 error 标记。例如，假设你的语言有一个关于 print 的语句的语法规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_statement_print(p):</span><br><span class="line">     &#39;statement : PRINT expr SEMI&#39;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<p>为了处理可能的错误表达式，你可以添加一条额外的语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_statement_print_error(p):</span><br><span class="line">     &#39;statement : PRINT error SEMI&#39;</span><br><span class="line">     print &quot;Syntax error in print statement. Bad expression&quot;</span><br></pre></td></tr></table></figure><br>这样（expr 错误时），error 标记会匹配任意多个分号之前的标记（分号是SEMI指代的字符）。一旦找到分号，规则将被匹配，这样 error 标记就被归约了。<br>这种类型的恢复有时称为”分析器再同步”。error 标记扮演了表示所有错误标记的通配符的角色，而紧随其后的标记扮演了同步标记的角色。</p>
<p>重要的一个说明是，通常 error 不会作为语法规则的最后一个标记，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_statement_print_error(p):</span><br><span class="line">    &#39;statement : PRINT error&#39;</span><br><span class="line">    print &quot;Syntax error in print statement. Bad expression&quot;</span><br></pre></td></tr></table></figure>
<p>这是因为，第一个导致错误的标记会使得该规则立刻归约，进而使得在后面还有错误标记的情况下，恢复变得困难。</p>
<ul>
<li>悲观恢复模式</li>
</ul>
<p>另一个错误恢复方法是采用“悲观模式”：该模式下，开始放弃剩余的标记，直到能够达到一个合适的恢复机会。</p>
<p>悲观恢复模式都是在 p_error() 方法中做到的。例如，这个方法在开始丢弃标记后，直到找到闭合的’}’，才重置分析器到初始化状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def p_error(p):</span><br><span class="line">    print &quot;Whoa. You are seriously hosed.&quot;</span><br><span class="line">    # Read ahead looking for a closing &#39;&#125;&#39;</span><br><span class="line">    while 1:</span><br><span class="line">        tok &#x3D; yacc.token()             # Get the next token</span><br><span class="line">        if not tok or tok.type &#x3D;&#x3D; &#39;RBRACE&#39;: break</span><br><span class="line">    yacc.restart()</span><br></pre></td></tr></table></figure>
<p>下面这个方法简单的抛弃错误的标记，并告知分析器错误被接受了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def p_error(p):</span><br><span class="line">    print &quot;Syntax error at token&quot;, p.type</span><br><span class="line">    # Just discard the token and tell the parser it&#39;s okay.</span><br><span class="line">    yacc.errok()</span><br></pre></td></tr></table></figure><br>在p_error()方法中，有三个可用的方法来控制分析器的行为：</p>
<ul>
<li>yacc.errok() 这个方法将分析器从恢复模式切换回正常模式。这会使得不会产生 error 标记，并重置内部的 error 计数器，而且下一个语法错误会再次产生 p_error() 调用</li>
<li>yacc.token() 这个方法用于得到下一个标记</li>
<li>yacc.restart() 这个方法抛弃当前整个分析栈，并重置分析器为起始状态</li>
</ul>
<p>注意：这三个方法只能在p_error()中使用，不能用在其他任何地方。</p>
<p>p_error()方法也可以返回标记，这样能够控制将哪个标记作为下一个标记返回给分析器。这对于需要同步一些特殊标记的时候有用，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def p_error(p):</span><br><span class="line">    # Read ahead looking for a terminating &quot;;&quot;</span><br><span class="line">    while 1:</span><br><span class="line">        tok &#x3D; yacc.token()             # Get the next token</span><br><span class="line">        if not tok or tok.type &#x3D;&#x3D; &#39;SEMI&#39;: break</span><br><span class="line">    yacc.errok()</span><br><span class="line"></span><br><span class="line">    # Return SEMI to the parser as the next lookahead token</span><br><span class="line">    return tok</span><br></pre></td></tr></table></figure>
<ul>
<li>从产生式中抛出错误</li>
</ul>
<p>如果有需要的话，产生式规则可以主动的使分析器进入恢复模式。这是通过抛出SyntaxError异常做到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_production(p):</span><br><span class="line">    &#39;production : some production ...&#39;</span><br><span class="line">    raise SyntaxError</span><br></pre></td></tr></table></figure>
<p>raise SyntaxError 错误的效果就如同当前的标记是错误标记一样。因此，当你这么做的话，最后一个标记将被弹出栈，当前的下一个标记将是 error 标记，分析器进入恢复模式，试图归约满足 error 标记的规则。此后的步骤与检测到语法错误的情况是完全一样的，p_error() 也会被调用。<br>手动设置错误有个重要的方面，就是 p_error() 方法在这种情况下不会调用。如果你希望记录错误，确保在抛出 SyntaxError 错误的产生式中实现。</p>
<p>注：这个功能是为了模仿 yacc 中的YYERROR宏的行为</p>
<ul>
<li>错误恢复总结</li>
</ul>
<p>对于通常的语言，使用 error 规则和再同步标记可能是最合理的手段。这是因为你可以将语法设计成在一个相对容易恢复和继续分析的点捕获错误。悲观恢复模式只在一些十分特殊的应用中有用，这些应用往往需要丢弃掉大量输入，再寻找合理的同步点。</p>
<h3 id="行号和位置的跟踪"><a href="#行号和位置的跟踪" class="headerlink" title="行号和位置的跟踪"></a>行号和位置的跟踪</h3><p>位置跟踪通常是个设计编译器时的技巧性玩意儿。默认情况下，PLY 跟踪所有标记的行号和位置，这些信息可以这样得到：</p>
<ul>
<li>p.lineno(num) 返回第 num 个符号的行号</li>
<li>p.lexpos(num) 返回第 num 个符号的词法位置偏移<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def p_expression(p):</span><br><span class="line">    &#39;expression : expression PLUS expression&#39;</span><br><span class="line">    p.lineno(1)        # Line number of the left expression</span><br><span class="line">    p.lineno(2)        # line number of the PLUS operator</span><br><span class="line">    p.lineno(3)        # line number of the right expression</span><br><span class="line">    ...</span><br><span class="line">    start,end &#x3D; p.linespan(3)    # Start,end lines of the right expression</span><br><span class="line">    starti,endi &#x3D; p.lexspan(3)   # Start,end positions of right expression</span><br></pre></td></tr></table></figure>
注意：lexspan() 方法只会返回的结束位置是最后一个符号的起始位置。<br>虽然，PLY 对所有符号的行号和位置的跟踪很管用，但经常是不必要的。例如，你仅仅是在错误信息中使用行号，你通常可以仅仅使用关键标记的信息，比如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def p_bad_func(p):</span><br><span class="line">    &#39;funccall : fname LPAREN error RPAREN&#39;</span><br><span class="line">    # Line number reported from LPAREN token</span><br><span class="line">    print &quot;Bad function call at line&quot;, p.lineno(2)</span><br></pre></td></tr></table></figure>
<p>类似的，为了改善性能，你可以有选择性的将行号信息在必要的时候进行传递，这是通过 p.set_lineno() 实现的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def p_fname(p):</span><br><span class="line">    &#39;fname : ID&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line">    p.set_lineno(0,p.lineno(1))</span><br></pre></td></tr></table></figure><br>对于已经完成分析的规则，PLY 不会保留行号信息，如果你是在构建抽象语法树而且需要行号，你应该确保行号保留在树上。</p>
<h3 id="构造抽象语法树"><a href="#构造抽象语法树" class="headerlink" title="构造抽象语法树"></a>构造抽象语法树</h3><p>yacc.py 没有构造抽像语法树的特殊方法。不过，你可以自己很简单的构造出来。</p>
<p>一个最为简单的构造方法是为每个语法规则创建元组或者字典，并传递它们。有很多中可行的方案，下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def p_expression_binop(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression PLUS expression</span><br><span class="line">                  | expression MINUS expression</span><br><span class="line">                  | expression TIMES expression</span><br><span class="line">                  | expression DIVIDE expression&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    p[0] &#x3D; (&#39;binary-expression&#39;,p[2],p[1],p[3])</span><br><span class="line"></span><br><span class="line">def p_expression_group(p):</span><br><span class="line">    &#39;expression : LPAREN expression RPAREN&#39;</span><br><span class="line">    p[0] &#x3D; (&#39;group-expression&#39;,p[2])</span><br><span class="line"></span><br><span class="line">def p_expression_number(p):</span><br><span class="line">    &#39;expression : NUMBER&#39;</span><br><span class="line">    p[0] &#x3D; (&#39;number-expression&#39;,p[1])</span><br></pre></td></tr></table></figure>
<p>另一种方法可以是为不同的抽象树节点创建一系列的数据结构，并赋值给 p[0]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Expr: pass</span><br><span class="line"></span><br><span class="line">class BinOp(Expr):</span><br><span class="line">    def __init__(self,left,op,right):</span><br><span class="line">        self.type &#x3D; &quot;binop&quot;</span><br><span class="line">        self.left &#x3D; left</span><br><span class="line">        self.right &#x3D; right</span><br><span class="line">        self.op &#x3D; op</span><br><span class="line"></span><br><span class="line">class Number(Expr):</span><br><span class="line">    def __init__(self,value):</span><br><span class="line">        self.type &#x3D; &quot;number&quot;</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line"></span><br><span class="line">def p_expression_binop(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression PLUS expression</span><br><span class="line">                  | expression MINUS expression</span><br><span class="line">                  | expression TIMES expression</span><br><span class="line">                  | expression DIVIDE expression&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    p[0] &#x3D; BinOp(p[1],p[2],p[3])</span><br><span class="line"></span><br><span class="line">def p_expression_group(p):</span><br><span class="line">    &#39;expression : LPAREN expression RPAREN&#39;</span><br><span class="line">    p[0] &#x3D; p[2]</span><br><span class="line"></span><br><span class="line">def p_expression_number(p):</span><br><span class="line">    &#39;expression : NUMBER&#39;</span><br><span class="line">    p[0] &#x3D; Number(p[1])</span><br></pre></td></tr></table></figure><br>这种方式的好处是在处理复杂语义时比较简单：类型检查、代码生成、以及其他针对树节点的功能。<br>为了简化树的遍历，可以创建一个通用的树节点结构，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self,type,children&#x3D;None,leaf&#x3D;None):</span><br><span class="line">         self.type &#x3D; type</span><br><span class="line">         if children:</span><br><span class="line">              self.children &#x3D; children</span><br><span class="line">         else:</span><br><span class="line">              self.children &#x3D; [ ]</span><br><span class="line">         self.leaf &#x3D; leaf</span><br><span class="line"> </span><br><span class="line">def p_expression_binop(p):</span><br><span class="line">    &#39;&#39;&#39;expression : expression PLUS expression</span><br><span class="line">                  | expression MINUS expression</span><br><span class="line">                  | expression TIMES expression</span><br><span class="line">                  | expression DIVIDE expression&#39;&#39;&#39;</span><br><span class="line">    p[0] &#x3D; Node(&quot;binop&quot;, [p[1],p[3]], p[2])</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式动作"><a href="#嵌入式动作" class="headerlink" title="嵌入式动作"></a>嵌入式动作</h3><p>yacc 使用的分析技术只允许在规则规约后执行动作。假设有如下规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def p_foo(p):</span><br><span class="line">    &quot;foo : A B C D&quot;</span><br><span class="line">    print &quot;Parsed a foo&quot;, p[1],p[2],p[3],p[4]</span><br></pre></td></tr></table></figure>
<p>方法只会在符号 A,B,C和D 都完成后才能执行。可是有的时候，在中间阶段执行一小段代码是有用的。假如，你想在 A 完成后立即执行一些动作，像下面这样用空规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def p_foo(p):</span><br><span class="line">    &quot;foo : A seen_A B C D&quot;</span><br><span class="line">    print &quot;Parsed a foo&quot;, p[1],p[3],p[4],p[5]</span><br><span class="line">    print &quot;seen_A returned&quot;, p[2]</span><br><span class="line">def p_seen_A(p):</span><br><span class="line">    &quot;seen_A :&quot;</span><br><span class="line">    print &quot;Saw an A &#x3D; &quot;, p[-1]   # Access grammar symbol to left</span><br><span class="line">    p[0] &#x3D; some_value            # Assign value to seen_A</span><br></pre></td></tr></table></figure><br>在这个例子中，空规则 seen_A 将在 A 移进分析栈后立即执行。p[-1] 指代的是在分析栈上紧跟在 seen_A 左侧的符号。在这个例子中，是 A 符号。像其他普通的规则一样，在嵌入式行为中也可以通过为 p[0] 赋值来返回某些值。<br>使用嵌入式动作可能会导致移进归约冲突，比如，下面的语法是没有冲突的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def p_foo(p):</span><br><span class="line">    &quot;&quot;&quot;foo : abcd</span><br><span class="line">           | abcx&quot;&quot;&quot;</span><br><span class="line">def p_abcd(p):</span><br><span class="line">    &quot;abcd : A B C D&quot;</span><br><span class="line">def p_abcx(p):</span><br><span class="line">    &quot;abcx : A B C X&quot;</span><br></pre></td></tr></table></figure>
<p>可是，如果像这样插入一个嵌入式动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def p_foo(p):</span><br><span class="line">    &quot;&quot;&quot;foo : abcd</span><br><span class="line">           | abcx&quot;&quot;&quot;</span><br><span class="line">def p_abcd(p):</span><br><span class="line">    &quot;abcd : A B C D&quot;</span><br><span class="line">def p_abcx(p):</span><br><span class="line">    &quot;abcx : A B seen_AB C X&quot;</span><br><span class="line">def p_seen_AB(p):</span><br><span class="line">    &quot;seen_AB :&quot;</span><br></pre></td></tr></table></figure><br>会产生移进归约冲，只是由于对于两个规则 abcd 和 abcx 中的 C，分析器既可以根据 abcd 规则移进，也可以根据 abcx 规则先将空的 seen_AB 归约。<br>嵌入动作的一般用于分析以外的控制，比如为本地变量定义作用于。对于 C 语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def p_statements_block(p):</span><br><span class="line">    &quot;statements: LBRACE new_scope statements RBRACE&quot;&quot;&quot;</span><br><span class="line">    # Action code</span><br><span class="line">    ...</span><br><span class="line">    pop_scope()        # Return to previous scope</span><br><span class="line"></span><br><span class="line">def p_new_scope(p):</span><br><span class="line">    &quot;new_scope :&quot;</span><br><span class="line">    # Create a new scope for local variables</span><br><span class="line">    s &#x3D; new_scope()</span><br><span class="line">    push_scope(s)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，new_scope 作为嵌入式行为，在左大括号{之后立即执行。可以是调正内部符号表或者其他方面。statements_block 一完成，代码可能会撤销在嵌入动作时的操作（比如，pop_scope())</p>
<h3 id="Yacc-的其他"><a href="#Yacc-的其他" class="headerlink" title="Yacc 的其他"></a>Yacc 的其他</h3><ul>
<li>默认的分析方法是 LALR，使用 SLR 请像这样运行 yacc()：yacc.yacc(method=”SLR”) 注意：LRLR 生成的分析表大约要比 SLR 的大两倍。解析的性能没有本质的区别，因为代码是一样的。由于 LALR 能力稍强，所以更多的用于复杂的语法。</li>
<li>默认情况下，yacc.py 依赖 lex.py 产生的标记。不过，可以用一个等价的词法标记生成器代替： yacc.parse(lexer=x) 这个例子中，x 必须是一个 Lexer 对象，至少拥有 x.token() 方法用来获取标记。如果将输入字串提供给 yacc.parse()，lexer 还必须具有 x.input() 方法。</li>
<li>默认情况下，yacc 在调试模式下生成分析表（会生成 parser.out 文件和其他东西），使用 yacc.yacc(debug=0) 禁用调试模式。</li>
<li>改变 parsetab.py 的文件名：yacc.yacc(tabmodule=”foo”)</li>
<li>改变 parsetab.py 的生成目录：yacc.yacc(tabmodule=”foo”,outputdir=”somedirectory”)</li>
<li>不生成分析表：yacc.yacc(write_tables=0)。注意：如果禁用分析表生成，yacc()将在每次运行的时候重新构建分析表（这里耗费的时候取决于语法文件的规模）</li>
<li>想在分析过程中输出丰富的调试信息，使用：yacc.parse(debug=1)</li>
<li>yacc.yacc()方法会返回分析器对象，如果你想在一个程序中支持多个分析器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; yacc.yacc()</span><br><span class="line">...</span><br><span class="line">p.parse()</span><br></pre></td></tr></table></figure>
注意：yacc.parse() 方法只绑定到最新创建的分析器对象上。</li>
<li>由于生成生成 LALR 分析表相对开销较大，先前生成的分析表会被缓存和重用。判断是否重新生成的依据是对所有的语法规则和优先级规则进行 MD5 校验，只有不匹配时才会重新生成。生成分析表是合理有效的办法，即使是面对上百个规则和状态的语法。对于复杂的编程语言，像 C 语言，在一些慢的机器上生成分析表可能要花费 30-60 秒，请耐心。</li>
<li>由于 LR 分析过程是基于分析表的，分析器的性能很大程度上取决于语法的规模。最大的瓶颈可能是词法分析器和语法规则的复杂度。<h2 id="多个语法和词法分析器"><a href="#多个语法和词法分析器" class="headerlink" title="多个语法和词法分析器"></a>多个语法和词法分析器</h2>在高级的分析器程序中，你可能同时需要多个语法和词法分析器。依照规则行事不会有问题。不过，你需要小心确定所有东西都正确的绑定(hooked up)了。首先，保证将 lex() 和 yacc() 返回的对象保存起来：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lexer  &#x3D; lex.lex()       # Return lexer object</span><br><span class="line">parser &#x3D; yacc.yacc()     # Return parser object</span><br></pre></td></tr></table></figure>
<p>接着，在解析时，确保给 parse() 方法一个正确的 lexer 引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.parse(text,lexer&#x3D;lexer)</span><br></pre></td></tr></table></figure><br>如果遗漏这一步，分析器会使用最新创建的 lexer 对象，这可能不是你希望的。<br>词法器和语法器的方法中也可以访问这些对象。在词法器中，标记的 lexer 属性指代的是当前触发规则的词法器对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def t_NUMBER(t):</span><br><span class="line">   r&#39;\d+&#39;</span><br><span class="line">   ...</span><br><span class="line">   print t.lexer           # Show lexer object</span><br></pre></td></tr></table></figure>
<p>在语法器中，lexer 和 parser 属性指代的是对应的词法器对象和语法器对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def p_expr_plus(p):</span><br><span class="line">   &#39;expr : expr PLUS expr&#39;</span><br><span class="line">   ...</span><br><span class="line">   print p.parser          # Show parser object</span><br><span class="line">   print p.lexer           # Show lexer object</span><br></pre></td></tr></table></figure><br>如果有必要，lexe r对象和 parser 对象都可以附加其他属性。例如，你想要有不同的解析器状态，可以为 parser 对象附加更多的属性，并在后面用到它们。</p>
<h2 id="使用Python的优化模式"><a href="#使用Python的优化模式" class="headerlink" title="使用Python的优化模式"></a>使用Python的优化模式</h2><p>由于 PLY 从文档字串中获取信息，语法解析和词法分析信息必须通过正常模式下的 Python 解释器得到（不带 有-O 或者 -OO 选项）。不过，如果你像这样指定 optimize 模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex.lex(optimize&#x3D;1)</span><br><span class="line">yacc.yacc(optimize&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>PLY 可以在下次执行，在 Python 的优化模式下执行。但你必须确保第一次执行是在 Python 的正常模式下进行，一旦词法分析表和语法分析表生成一次后，在 Python 优化模式下执行，PLY 会使用生成好的分析表而不再需要文档字串。</p>
<h2 id="高级调试"><a href="#高级调试" class="headerlink" title="高级调试"></a>高级调试</h2><p>调试一个编译器不是件容易的事情。PLY 提供了一些高级的调试能力，这是通过 Python 的l ogging 模块实现的，下面两节介绍这一主题：</p>
<h3 id="调试-lex-和-yacc-命令"><a href="#调试-lex-和-yacc-命令" class="headerlink" title="调试 lex() 和 yacc() 命令"></a>调试 lex() 和 yacc() 命令</h3><p>lex() 和 yacc() 命令都有调试模式，可以通过 debug 标识实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex.lex(debug&#x3D;True)</span><br><span class="line">yacc.yacc(debug&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>正常情况下，调试不仅输出标准错误，对于 yacc()，还会给出 parser.out 文件。这些输出可以通过提供 logging 对象来精细的控制。下面这个例子增加了对调试信息来源的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Set up a logging object</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level &#x3D; logging.DEBUG,</span><br><span class="line">    filename &#x3D; &quot;parselog.txt&quot;,</span><br><span class="line">    filemode &#x3D; &quot;w&quot;,</span><br><span class="line">    format &#x3D; &quot;%(filename)10s:%(lineno)4d:%(message)s&quot;</span><br><span class="line">)</span><br><span class="line">log &#x3D; logging.getLogger()</span><br><span class="line"></span><br><span class="line">lex.lex(debug&#x3D;True,debuglog&#x3D;log)</span><br><span class="line">yacc.yacc(debug&#x3D;True,debuglog&#x3D;log)</span><br></pre></td></tr></table></figure><br>如果你提供一个自定义的 logger，大量的调试信息可以通过分级来控制。典型的是将调试信息分为 DEBUG,INFO,或者 WARNING 三个级别。<br>PLY 的错误和警告信息通过日志接口提供，可以从 errorlog 参数中传入日志对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex.lex(errorlog&#x3D;log)</span><br><span class="line">yacc.yacc(errorlog&#x3D;log)</span><br></pre></td></tr></table></figure>
<p>如果想完全过滤掉警告信息，你除了可以使用带级别过滤功能的日志对象，也可以使用 lex 和 yacc 模块都内建的 Nulllogger 对象。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yacc.yacc(errorlog&#x3D;yacc.NullLogger())</span><br></pre></td></tr></table></figure></p>
<h3 id="运行时调试"><a href="#运行时调试" class="headerlink" title="运行时调试"></a>运行时调试</h3><p>为分析器指定 debug 选项，可以激活语法分析器的运行时调试功能。这个选项可以是整数（表示对调试功能是开还是关），也可以是 logger 对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log &#x3D; logging.getLogger()</span><br><span class="line">parser.parse(input,debug&#x3D;log)</span><br></pre></td></tr></table></figure>
<p>如果传入日志对象的话，你可以使用其级别过滤功能来控制内容的输出。INFO 级别用来产生归约信息；DEBUG 级别会显示分析栈的信息、移进的标记和其他详细信息。ERROR 级别显示分析过程中的错误相关信息。<br>对于每个复杂的问题，你应该用日志对象，以便输出重定向到文件中，进而方便在执行结束后检查。</p>
<h1 id="写一个计算器"><a href="#写一个计算器" class="headerlink" title="写一个计算器"></a>写一个计算器</h1><h3 id="Lex文件"><a href="#Lex文件" class="headerlink" title="Lex文件"></a>Lex文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">from ply import lex</span><br><span class="line"></span><br><span class="line"># Define &#96;tokens&#96;, a list of token names.</span><br><span class="line">tokens &#x3D; ( &#39;PLUS&#39;, &#39;MINUS&#39;, &#39;MULT&#39;, &#39;DIV&#39;, &#39;EXPONENT&#39;, \</span><br><span class="line">        &#39;LPAREN&#39;, &#39;RPAREN&#39;, &#39;AB&#39;, &#39;NUMBER&#39;, \</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"># Define &#96;t_ignore&#96; to ignore unnecessary characters between tokens, such as whitespaces.</span><br><span class="line">t_ignore &#x3D; &quot; \t&quot;</span><br><span class="line"></span><br><span class="line"># Define functions representing regular expression rules for each token.</span><br><span class="line"># The name of functions must be like &#96;t_&lt;token_name&gt;&#96;.</span><br><span class="line"># Functions accept one argument, which is a parsed token.</span><br><span class="line">#    t.type  : name of token</span><br><span class="line">#    t.value : string of parsed token </span><br><span class="line">#    t.lineno: line number of token</span><br><span class="line">#    t.lexpos: position of token from the beginning of input string</span><br><span class="line"></span><br><span class="line">def t_PLUS(t):</span><br><span class="line">    r&#39;\+&#39; # regular expression for the token</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_MINUS(t):</span><br><span class="line">    r&#39;\-&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line"># The order of declaration is also the order of rules the lexer uses.</span><br><span class="line"># That is why &#96;t_EXPONENT&#96; must be before &#96;t_MULT&#96;.</span><br><span class="line">def t_EXPONENT(t):</span><br><span class="line">    r&#39;\*\*&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_MULT(t):</span><br><span class="line">    r&#39;\*&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_DIV(t):</span><br><span class="line">    r&#39;&#x2F;&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_LPAREN(t):</span><br><span class="line">    r&#39;\(&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_RPAREN(t):</span><br><span class="line">    r&#39;\)&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_AB(t):</span><br><span class="line">    r&#39;ab&#39;</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line">def t_NUMBER(t):</span><br><span class="line">    r&#39;[0-9]+&#39;</span><br><span class="line">    t.value &#x3D; int(t.value)</span><br><span class="line">    return t</span><br><span class="line"></span><br><span class="line"># To count correct line number</span><br><span class="line">def t_newline(t):</span><br><span class="line">    r&#39;\n+&#39;</span><br><span class="line">    t.lexer.lineno +&#x3D; t.value.count(&quot;\n&quot;)</span><br><span class="line">    # return None, so this newlines will not be in the parsed token list.</span><br><span class="line"></span><br><span class="line"># Special function for error handling</span><br><span class="line">def t_error(t):</span><br><span class="line">    print(&quot;illegal character &#39;%s&#39;&quot; % (t.value[0]))</span><br><span class="line">    t.lexer.skip(1)</span><br><span class="line"></span><br><span class="line"># Generate a lexer by &#96;lex.lex()&#96;</span><br><span class="line">lexer &#x3D; lex.lex()</span><br><span class="line"></span><br><span class="line">def test_lexer(input_string):</span><br><span class="line">    lexer.input(input_string)</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    while True:</span><br><span class="line">        tok &#x3D; lexer.token()</span><br><span class="line">        if not tok:</span><br><span class="line">            break</span><br><span class="line">        result &#x3D; result + [(tok.type, tok.value)]</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(test_lexer(&#39;1 + 2&#39;))</span><br><span class="line">    print(test_lexer(&#39;1 + 20 * 3 - 10 &#x2F; -2 * (1 + 3)&#39;))</span><br><span class="line">    print(test_lexer(&#39;1 ** 2&#39;))</span><br><span class="line">    print(test_lexer(&#39;ab 5 + ab -2 * ab (1 - 2)&#39;))</span><br></pre></td></tr></table></figure>
<h3 id="Yacc文件"><a href="#Yacc文件" class="headerlink" title="Yacc文件"></a>Yacc文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">from ply import yacc</span><br><span class="line">from calclexer import tokens, lexer</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Grammars:</span><br><span class="line">S -&gt; E</span><br><span class="line">E -&gt; E + E</span><br><span class="line">E -&gt; E - E</span><br><span class="line">E -&gt; E * E</span><br><span class="line">E -&gt; E &#x2F; E</span><br><span class="line">E -&gt; E ** E</span><br><span class="line">E -&gt; N</span><br><span class="line">E -&gt; +N</span><br><span class="line">E -&gt; -N</span><br><span class="line">E -&gt; ab E</span><br><span class="line">E -&gt; (E)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># (optional) Define precedence and associativity of operators.</span><br><span class="line"># The format is ( (&#39;left&#39; or &#39;right&#39;, &lt;token name&gt;, ...), (...) ).</span><br><span class="line"># &lt;token name&gt; is expected to be defined in the lexer definition.</span><br><span class="line"># The latter has the the higher precedence (e.g. &#39;MULT&#39; and &#39;DIV&#39; have the higher precedence than &#39;PLUS&#39; and &#39;MINUS&#39;).</span><br><span class="line"># &#39;UPLUS&#39; and &#39;UMINUS&#39; are defined as aliases to override precedence (see &#96;p_expr_um_num&#96;)</span><br><span class="line">precedence &#x3D; ( \</span><br><span class="line">        (&#39;left&#39;, &#39;PLUS&#39;, &#39;MINUS&#39;), \</span><br><span class="line">        (&#39;left&#39;, &#39;MULT&#39;, &#39;DIV&#39;), \</span><br><span class="line">        (&#39;right&#39;, &#39;EXPONENT&#39;), \</span><br><span class="line">        (&#39;right&#39;, &#39;UPLUS&#39;, &#39;UMINUS&#39;, &#39;AB&#39;), \</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"># Parsing rules</span><br><span class="line"># Functions should be start with &#96;p_&#96;.</span><br><span class="line"># The first rule will be the starting rule of parsing (?).</span><br><span class="line"></span><br><span class="line"># S -&gt; E</span><br><span class="line">def p_statement(p):</span><br><span class="line">    &#39;statement : expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line"></span><br><span class="line"># E -&gt; E + E</span><br><span class="line">def p_expr_plus(p):</span><br><span class="line">    &#39;expr : expr PLUS expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1] + p[3]</span><br><span class="line"></span><br><span class="line"># E -&gt; E - E</span><br><span class="line">def p_expr_minus(p):</span><br><span class="line">    &#39;expr : expr MINUS expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1] - p[3]</span><br><span class="line"></span><br><span class="line"># E -&gt; E * E</span><br><span class="line">def p_expr_mult(p):</span><br><span class="line">    &#39;expr : expr MULT expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1] * p[3]</span><br><span class="line"></span><br><span class="line"># E -&gt; E &#x2F; E</span><br><span class="line">def p_expr_div(p):</span><br><span class="line">    &#39;expr : expr DIV expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1] &#x2F; p[3]</span><br><span class="line"></span><br><span class="line"># E -&gt; E ** E</span><br><span class="line">def p_expr_exponent(p):</span><br><span class="line">    &#39;expr : expr EXPONENT expr&#39;</span><br><span class="line">    p[0] &#x3D; p[1] ** p[3]</span><br><span class="line"></span><br><span class="line"># E -&gt; N</span><br><span class="line">def p_expr_num(p):</span><br><span class="line">    &#39;expr : NUMBER&#39;</span><br><span class="line">    p[0] &#x3D; p[1]</span><br><span class="line"></span><br><span class="line"># E -&gt; +N</span><br><span class="line">def p_expr_up_num(p):</span><br><span class="line">    &#39;expr : PLUS NUMBER %prec UPLUS&#39; # override precedence of PLUS by &#96;%prec UPLUS&#96;</span><br><span class="line">    p[0] &#x3D; p[2]</span><br><span class="line"></span><br><span class="line"># E -&gt; -N</span><br><span class="line">def p_expr_um_num(p):</span><br><span class="line">    &#39;expr : MINUS NUMBER %prec UMINUS&#39; # override precedence of MINUS by &#96;%prec UMINUS&#96;</span><br><span class="line">    p[0] &#x3D; -p[2]</span><br><span class="line"></span><br><span class="line"># E -&gt; ab E</span><br><span class="line">def p_expr_ab(p):</span><br><span class="line">    &#39;expr : AB expr&#39;</span><br><span class="line">    p[0] &#x3D; abs(p[2])</span><br><span class="line"></span><br><span class="line"># E -&gt; ( E )</span><br><span class="line">def p_expr_paren(p):</span><br><span class="line">    &#39;expr : LPAREN expr RPAREN&#39;</span><br><span class="line">    p[0] &#x3D; p[2]</span><br><span class="line"></span><br><span class="line"># Rule for error handling</span><br><span class="line">def p_error(t):</span><br><span class="line">    print(&quot;syntax error at &#39;%s&#39;&quot; % (t.value))</span><br><span class="line"></span><br><span class="line"># Generate a LALR parser</span><br><span class="line">parser &#x3D; yacc.yacc()</span><br><span class="line"></span><br><span class="line">def parse(input_string):</span><br><span class="line">    lexer.input(input_string)</span><br><span class="line">    parse_tree &#x3D; parser.parse(input_string, lexer&#x3D;lexer)</span><br><span class="line">    return parse_tree</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    assert parse(&#39;1 + 2 + 3&#39;) &#x3D;&#x3D; 6</span><br><span class="line">    assert parse(&#39;1 + 2 * 3 * 4&#39;) &#x3D;&#x3D; 25</span><br><span class="line">    assert parse(&#39;3 * 4 - 10 &#x2F; 2 + 5&#39;) &#x3D;&#x3D; 12</span><br><span class="line">    assert parse(&#39;-3 * (+4 - 10) &#x2F; -2 + 5&#39;) &#x3D;&#x3D; -4</span><br><span class="line">    assert parse(&#39;1 + 2 ** 3 ** 2&#39;) &#x3D;&#x3D; 513</span><br><span class="line">    assert parse(&#39;ab (1 - 2  -3)&#39;) &#x3D;&#x3D; 4</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="majsunflower.cn/2020/03/03/PLY%E6%95%99%E7%A8%8B%E5%8F%8A%E4%BE%8B%E5%AD%90/" data-id="ckj763pgo0031j9wvfqll5rd7"
         class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" rel="tag">工具使用</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/03/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E3%80%8AReformer-The-Efficient-Transformer%E3%80%8B/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            论文阅读：《Reformer: The Efficient Transformer》
          
        </div>
      </a>
    
    
      <a href="/2020/02/26/Spark%E5%85%A5%E9%97%A8/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">Spark入门</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'a0115c330d8e2a88dc59',
      clientSecret: '2e456ec13123a898d7b34ad8e117f543a6f379ea',
      repo: 'majing2019.github.io',
      owner: 'majing2019',
      admin: ['majing2019'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 大嘴怪的小世界</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/shark.svg" alt="大嘴怪的小世界"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>




<script src="/js/ocean.js"></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>